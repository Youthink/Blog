<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胡方运的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hufangyun.com/"/>
  <updated>2019-11-26T16:00:00.000Z</updated>
  <id>https://hufangyun.com/</id>
  
  <author>
    <name>小猿大圣</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何给网站添加免费的 https 证书</title>
    <link href="https://hufangyun.com/2019/https-config/"/>
    <id>https://hufangyun.com/2019/https-config/</id>
    <published>2019-11-26T16:00:00.000Z</published>
    <updated>2019-11-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<img alt="https" src="https://static.hufangyun.com/hexo/img/https-config.jpg"><span class="img-alt">https</span><p>最近部署了一个新服务，想给域名启用 <code>https</code>，结果搜了半天，在我的博客里只发现了这一篇笔记：<a href="https://hufangyun.com/2017/https-aliyun-free/">阿里云免费证书域名启用 https</a></p><p>😹 只能说给网站启用 <code>https</code> 太简单了，之前都没留下笔记，为了之后方便，简单记录一下。</p><p>我使用的是 <a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s Encrypt</a> 的免费证书。</p><p>按照下面的操作一步步来就行了。</p><p>1、去 <a href="https://certbot.eff.org/" target="_blank" rel="noopener">certbot</a> 官网。</p><p>2、在页面上选择一下你用的 <code>Web</code> 服务器和操作系统。比如，我选的 <code>Nginx</code> 和 <code>Ubuntu 18.04</code></p><p>3、页面上会出现操作步骤，按照提示的步骤一步步执行命令就可以了。</p><p>需要注意执行到 <code>sudo certbot --nginx</code> 的时候，会出现两个协议：</p><p>第一个，是问你要不要同意他们的服务协议，选择“同意”。</p><p>第二个，是问你要不要共享你的邮箱给他们，他们偶尔会发一些他们基金会的新闻一类的。我选了“不同意”（因为我不知道以后有没有退订选项 😂）。</p><p>之后 <code>certbot</code> 会自动扫描你的 <code>Nginx</code> 的配置，寻找域名列表然后让你选择想配置 <code>https</code> 证书的域名（好像可以同时配置多个域名）。</p><p>如果没找到域名的话，会让你手动输入一个域名。</p><p>之后会问你，要不要强制把 <code>http</code> 的链接跳转到 <code>https</code> 上，当然选“是”了。</p><p>之后 <code>certbot</code> 会帮你把 <code>Nginx</code> 一切都配置好。你直接访问域名看一下效果即可。服务真是相当的贴心。。。。🎉</p><p>耗叔的这篇文章 <a href="https://coolshell.cn/articles/18094.html" target="_blank" rel="noopener">如何免费的让网站启用HTTPS|酷 壳 - CoolShell</a> 提到配置<code>http2</code> 传输性能更好。</p><blockquote><p>要求 <code>Nginx</code> 版本要大于 <code>1.9.5</code>。<code>HTTP2</code> 具有更快的 <code>HTTPS</code> 传输性能，非常值得开启。需要开启 <code>HTTP/2</code> 其实很简单，只需要在 <code>nginx.conf</code> 的 <code>listen 443 ssl;</code> 后面加上 <code>http2</code> 就好了。如下所示：</p></blockquote><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">443</span> ssl http2; <span class="comment"># managed by Certbot </span></span><br><span class="line"><span class="attribute">ssl_certificate</span> /etc/letsencrypt/live/coolshell.cn/fullchain.pem; <span class="comment"># managed by Certbot </span></span><br><span class="line"><span class="attribute">ssl_certificate_key</span> /etc/letsencrypt/live/coolshell.cn/privkey.pem; <span class="comment"># managed by Certbot </span></span><br><span class="line"><span class="attribute">include</span> /etc/letsencrypt/options-ssl-nginx.conf; <span class="comment"># managed by Certbot</span></span><br></pre></td></tr></table></figure><p>然后，<code>nginx -s reload</code> 就好了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img alt=&quot;https&quot; src=&quot;https://static.hufangyun.com/hexo/img/https-config.jpg&quot;&gt;&lt;span class=&quot;img-alt&quot;&gt;https&lt;/span&gt;

&lt;p&gt;最近部署了一个新服务，想给域名启用 &lt;code
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>如何管理多个 git 账号</title>
    <link href="https://hufangyun.com/2019/multi-git-account/"/>
    <id>https://hufangyun.com/2019/multi-git-account/</id>
    <published>2019-10-02T07:35:16.000Z</published>
    <updated>2019-10-02T07:35:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果你有多个 git 账户，有没有遇到过提交代码的用户信息混乱的情况？ 如果一劳永逸的解决这个问题那？</p></blockquote><h2 id="分目录配置-git-用户信息"><a href="#分目录配置-git-用户信息" class="headerlink" title="分目录配置 git 用户信息"></a>分目录配置 git 用户信息</h2><p><code>git</code> 可以设置全局的用户信息，然后可以再单独为每个仓库设置用户信息。如果忘记了给项目重置用户信息，可能就会发生上面的问题 — 提交时的邮箱和用户名错了。😓</p><p>如果你喜欢用不同的目录区分个人和公司的项目，可以使用下面的方法配置自己的 <code>git</code> 用户信息。😀</p><p>比如，你把公司的项目都放在了 <code>Company</code> 目录下，个人的项目都放在了 <code>Personal</code> 目录下下面。</p><p>那你可以这么做：</p><p>在 <code>Company</code> 下新建一个 <code>.gitconfig_include</code> 文件，配置你想在该目录下给所有 <code>git</code> 仓库设置的用户信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">  name = 用户名</span><br><span class="line">  email = 邮箱</span><br></pre></td></tr></table></figure><p>然后在 <code>~/.gitconfig</code> 内添加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[includeIf &quot;gitdir:~/Company/&quot;]</span><br><span class="line">  path = ~/Company/.gitconfig_include</span><br></pre></td></tr></table></figure><p>⚠️ 复制提醒。<code>Company</code> 要替换成你自己的目录</p><p>这样，之后 <code>Company</code> 目录下的 <code>git</code> 仓库都会使用对应的 <code>git</code> 用户信息。💪</p><p>这是 git 的一个用法，感兴趣的同学可以看这里 <a href="https://git-scm.com/docs/git-config#_conditional_includes" target="_blank" rel="noopener">conditional includes </a> </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/21307793/set-git-config-values-for-all-child-folders" target="_blank" rel="noopener">Set git config values for all child folders</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;如果你有多个 git 账户，有没有遇到过提交代码的用户信息混乱的情况？ 如果一劳永逸的解决这个问题那？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;分目录配置-git-用户信息&quot;&gt;&lt;a href=&quot;#分目录配置-git-用户信息&quot; clas
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>写给自己的JavaScript系列之一步步写个 JavaScript 解释器</title>
    <link href="https://hufangyun.com/2019/js-interpreter/"/>
    <id>https://hufangyun.com/2019/js-interpreter/</id>
    <published>2019-03-11T14:20:21.000Z</published>
    <updated>2019-04-23T14:20:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了更好的理解 JavaScript 的各种语言特性，更好的掌握 JavaScript 的底层原理 😄。我想动手写一个 JavaScript 版的 JavaScript 解释器。简单来说，就是能够运行 JavaScript（以下简称 js ） 代码。我们平时写的 js 代码一般由浏览器或者 Nodejs 的解释器来解释并执行，本文的目标就是写一个能够解释 js 代码的解释器 🚀。</p><p>写一个解释器的工程，想一想就感觉好大。咱们可以拆解一下，一步步来。每实现一个小目标都会很有成就感，不至于望而却步 🐶。</p><h2 id="第一阶段的目标"><a href="#第一阶段的目标" class="headerlink" title="第一阶段的目标"></a>第一阶段的目标</h2><p>✅ 1、首先实现打印值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">'Hello World!'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>2、然后实现加减乘除四则运算</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x + y);</span><br></pre></td></tr></table></figure><p>3、然后我们实现函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>4、趁热打铁实现闭包。</p><blockquote><p>实现闭包其实我想写一个 js 解释器的初始动机，我本来在写一篇解释什么是 js 闭包的文章，但是我写着写着感觉有点无聊，没什么意思，就想实现个 js 解释器。 从另一个角度理解这个问题。</p></blockquote><p>6、实现 if 条件表达式</p><p>7、实现 for 循环</p><p>8、打包 js 可以在其他文件内使用</p><blockquote><p>将执行结果输出到外部</p></blockquote><p>上面是我的玩具计划。</p><p>😌 ———————— 这是一条分割线 ———————- 😌</p><p>下面是我的开发过程。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>我找到的一些用 js 实现 js 解释器的文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/34191831" target="_blank" rel="noopener">微信小程序也要强行热更代码，鹅厂不服你来肛我呀</a></li><li><a href="https://juejin.im/post/5aa25be1518825557b4c5720#heading-11" target="_blank" rel="noopener">从零开始写一个Javascript解析器</a></li><li><a href="https://segmentfault.com/a/1190000017241258" target="_blank" rel="noopener">前端与编译原理——用JS写一个JavaScript解释器</a></li></ul><p>和上面文章相关的 Github 上的 JavaScript 解释器源码</p><blockquote><p>前三个是 TypeScript 项目，最后一个是 JavaScript 项目</p></blockquote><ul><li><a href="https://github.com/bramblex/jsjs" target="_blank" rel="noopener">jsjs</a></li><li><a href="https://github.com/jkeylu/evil-eval" target="_blank" rel="noopener">evil-eval</a></li><li><a href="https://github.com/axetroy/vm.js" target="_blank" rel="noopener">vm.js</a></li><li><a href="https://github.com/jrainlau/canjs" target="_blank" rel="noopener">canjs</a></li></ul><h2 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h2><p>JavaScript 代码转化成抽象语法树（AST）这一步，直接用现成的库实现。这里我们使用 <a href="https://github.com/acornjs/acorn" target="_blank" rel="noopener"><code>acorn</code></a> 库。这是一个 js 的解析器，可以将 js 代码解析成 AST，<code>Babel</code> 最开始也使用了 <code>acorn</code>。</p><p>如果你想了解整个编译器的开发（包括 AST 的生成），可以看这个项目<a href="https://github.com/jamiebuilds/the-super-tiny-compiler" target="_blank" rel="noopener">微型编译器</a></p><h3 id="抽象语法树（AST）"><a href="#抽象语法树（AST）" class="headerlink" title="抽象语法树（AST）"></a>抽象语法树（AST）</h3><p>大体解释一下。🐵</p><blockquote><p>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于 if-condition-then 这样的条件跳转语句，可以使用带有两个分支的节点来表示。  – 维基百科</p></blockquote><p>AST 的作用：</p><ul><li>代码风格检测(eslint等)</li><li>代码的格式化，自动补全</li><li>代码高亮</li><li>代码错误检查</li><li>代码的混淆压缩</li><li>转换代码的工具。如 webpack，rollup。各种代码规范之间的转换，TypeScript JSX 等转换为原生 js</li></ul><p>实际项目中对 AST 的应用：</p><p>我在网上找到的三个案例：🌏</p><p><a href="https://segmentfault.com/a/1190000013423155" target="_blank" rel="noopener">分析统计微信小程序代码使用的 api</a></p><p><a href="https://qianduan.group/posts/5a0fe3cc44aec04413ec3d7d" target="_blank" rel="noopener">支付宝和微信小程序的代码转换</a></p><p><a href="https://tech.meituan.com/2014/10/08/the-practice-of-abstract-syntax-trees-in-javascript.html" target="_blank" rel="noopener">美团的模块依赖关系检测工具</a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1、使用 acorn 将 js 转换成 ast 抽象语法树</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Parser &#125; = <span class="built_in">require</span>(<span class="string">'acorn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runjs</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(code = '') &#123;</span><br><span class="line">    <span class="keyword">this</span>.ast = Parser.parse(code);</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.ast);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Runjs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Runjs(<span class="string">`</span></span><br><span class="line"><span class="string">  let x = 'Hello World!';</span></span><br><span class="line"><span class="string">  console.log(x);</span></span><br><span class="line"><span class="string">`</span>).run();</span><br></pre></td></tr></table></figure><p>我们可以使用这个工具看一下，解析出来的抽象语法树。😉</p><p><a href="http://esprima.org/demo/parse.html" target="_blank" rel="noopener">Esprima 在线工具</a></p><p><a href="https://astexplorer.net/" target="_blank" rel="noopener">ast</a></p><p>2、解析出来的 AST 每个节点都有个 type 属性，要做一个节点遍历器，处理每一个节点。</p><p>有哪些节点那？可以从这里<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API" target="_blank" rel="noopener">查看</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">'Hello World!'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>⬇️ 上面的代码生成的 AST 如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"Program"</span>,</span><br><span class="line">  <span class="attr">"body"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"VariableDeclaration"</span>,</span><br><span class="line">      <span class="attr">"declarations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"VariableDeclarator"</span>,</span><br><span class="line">          <span class="attr">"id"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"x"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"init"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Literal"</span>,</span><br><span class="line">            <span class="attr">"value"</span>: <span class="string">"Hello World!"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"kind"</span>: <span class="string">"const"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"ExpressionStatement"</span>,</span><br><span class="line">      <span class="attr">"expression"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"CallExpression"</span>,</span><br><span class="line">        <span class="attr">"callee"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"MemberExpression"</span>,</span><br><span class="line">          <span class="attr">"computed"</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">"object"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"console"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"property"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"log"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"arguments"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"x"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实现节点遍历器？</p><p>先定义一个节点控制器 nodeHandler，分别处理每一个节点</p><p>下面是上面用到的节点类型：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nodeHandler = &#123;</span><br><span class="line">  Program(nodeIterator) &#123;</span><br><span class="line">    <span class="comment">/*处理 Program 类型的代码 */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  VariableDeclaration(nodeIterator) &#123;</span><br><span class="line">    <span class="comment">/*处理 VariableDeclaration 类型的代码 */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  Identifier(nodeIterator) &#123;&#125;,</span><br><span class="line">  Literal(nodeIterator) &#123;&#125;,</span><br><span class="line">  ExpressionStatement(nodeIterator) &#123;&#125;,</span><br><span class="line">  CallExpression(nodeIterator) &#123;&#125;,</span><br><span class="line">  MemberExpression(nodeIterator) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现一个节点遍历器 🆗</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeIterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(node) &#123;</span><br><span class="line">    <span class="keyword">this</span>.node = node;</span><br><span class="line">    <span class="keyword">this</span>.nodeHandler = nodeHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  traverse(node) &#123;</span><br><span class="line">    <span class="keyword">const</span> nodeIterator = <span class="keyword">new</span> NodeIterator(node);</span><br><span class="line">    <span class="keyword">const</span> parse = <span class="keyword">this</span>.nodeHandler[node.type];</span><br><span class="line">    <span class="keyword">if</span> (!parse) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`canjs: Unknown node type "<span class="subst">$&#123;node.type&#125;</span>".`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parse(nodeIterator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（未完待续<del>~</del>）🎈</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了更好的理解 JavaScript 的各种语言特性，更好的掌握 JavaScript 的底层原理 😄。我想动手写一个 JavaScript 版的 JavaScript 解释器。简单来说，就是能够运行 JavaScript（以下简称 js ） 代码。我们平时写的 js 代
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 文件的异步加载 async 和 defer</title>
    <link href="https://hufangyun.com/2018/js-async/"/>
    <id>https://hufangyun.com/2018/js-async/</id>
    <published>2018-11-05T07:32:06.000Z</published>
    <updated>2019-10-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 webpack 等工具的照料下，我们忘记了很多的东西，比如说 JavaScript 文件的异步加载，异步执行等等内容。唯一能记起是关于 script 的优化可能是把 script 标签放到页面底部。</p><p>某次你看到 ‘<script src="mylib.js" async></script>‘ 这样的引入语句，请问这 async 到底是什么意义呢？</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>1、学习 async 的作用，使用限制等。</p><p>2、有没有其他类似的属性呢？</p><h2 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h2><p>性能优化</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>聊 JavaScript 文件的异步加载之前，我们先来看一段 HTML 文档的加载流程。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://a.com/a.js"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="undefined">  这里有很多的 HTML 标签和内容</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>对于上面的 HTML 文档，浏览器的解析过程如下：</p><p>1、浏览器一边下载 HTML 网页，一边开始解析(并不是下载完之后，才开始开始解析)。</p><p>2、解析过程中，浏览器发现 <code>&lt;script&gt;</code> 标签就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</p><p>3、如果 <code>&lt;script&gt;</code> 标签引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</p><p>4、JavaScript 引擎执行完毕，控制权交还渲染引擎，继续解析 HTML 网页。</p><p>加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后再继续渲染。</p><img src="https://static.hufangyun.com/hexo/img/js-async-2.jpg?imageView2/2/w/600"><p>这就是为什么我们一般建议把 <code>&lt;script&gt;</code> 标签放在 <code>&lt;/body&gt;</code> 之前，而不是放在 <code>&lt;head&gt;&lt;/head&gt;</code> 中，因为加载 <code>&lt;script&gt;</code> 中的脚本并执行会阻塞 HTML 页面的渲染，当 JavaScript 文件很大的时候，甚至会长时间出现白屏。</p><p>有没有什么办法可以优化 JavaScript 文件的加载执行，提高页面加载的效率？</p><h2 id="解读-async-和-defer-属性"><a href="#解读-async-和-defer-属性" class="headerlink" title="解读 async 和 defer 属性"></a>解读 async 和 defer 属性</h2><p>翻阅 <a href="https://www.w3.org/TR/html51/semantics-scripting.html" target="_blank" rel="noopener">HTML5 的文档</a> 就会发现，<code>&lt;script&gt;</code> 还有 <code>async</code> 和 <code>defer</code> 两个和脚本加载执行有关的属性。</p><blockquote><p>async - Execute script in parallel //并行执行脚本</p><p>defer - Defer script execution // 延迟执行脚本</p></blockquote><p><a href="https://www.w3.org/TR/html4/interact/scripts.html#18.2.1" target="_blank" rel="noopener">HTML4.1</a>是这么解释 defer 的：</p><blockquote><p>When set, this boolean attribute provides a hint to the user agent that the script is not going to generate any document content (e.g., no “document.write” in javascript) and thus, the user agent can continue parsing and rendering.</p></blockquote><p>就是说浏览器在遇到设置了 defer 的 <code>&lt;script&gt;</code> 时，加载了 JavaScript 文件后，不会立即执行，不会阻塞浏览器解析 HTML，而且如果设置了 defer 不要在 JavaScript 脚本里写 <code>document.write</code>。</p><p><a href="https://www.w3.org/TR/html51/semantics-scripting.html" target="_blank" rel="noopener">HTML5.1</a>这么解释 defer 和 async 的：</p><p>此处省略将近 1500 字的英文引用，感兴趣点击的 <a href="https://www.w3.org/TR/html51/semantics-scripting.html" target="_blank" rel="noopener">HTML5.1</a> 文档。</p><p>对省略的原文总结如下：</p><p>1、defer 和 async 只对外部加载的脚本有效果，<code>&lt;script&gt;</code> 包含的 JavaScript 代码块无效。</p><p>2、必须设置了 <code>src</code> 属性，不然 defer 和 async 也无效。</p><p>3、defer 和 async 这两个值是布尔类型的。</p><p>4、如果设置了 async 属性，会并行加载脚本文件并执行，下载时不会阻塞 HTML 的解析，但是脚本执行的时候会阻塞 HTML 的解析。如果没有设置 async 属性，但是设置了 defer 属性，也会并行加载脚本文件，但是会等到页面完成解析再去执行。如果这两个属性都没有设置，会阻塞页面解析，加载并执行脚本文件。三种方式的对比图如下：</p><img alt="图片来源：www.w3c.org" src="https://static.hufangyun.com/hexo/img/js-async-1.jpg?imageView2/2/w/600"><span class="img-alt">图片来源：www.w3c.org</span><p><a href="https://www.w3.org/TR/html53/semantics-scripting.html#element-attrdef-script-defer" target="_blank" rel="noopener">HTML5.3</a>的文档把第四条补充了一下。。。</p><p>1、defer 对 module 脚本是无效的，但是 async 是有效的</p><p>2、如果同时设置了 defer 和 async 为 true， 以 defer 为准</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>通过给 <code>&lt;script&gt;</code> 标签设置 defer 属性，将脚本文件设置为延迟加载，当浏览器遇到带有 defer 属性的 <code>&lt;script&gt;</code> 标签时，会再开启一个线程去下载 JavaScript 文件，同时继续解析 HTML 文档，等 HTML 全部解析完毕 DOM 加载完成之后(也就是DOMContentLoaded 事件之后 onload 事件之前)，再去执行加载好的 JavaScript 文件。多个js文件的执行顺序就是它们在页面中出现的顺序。</p><p>async 属性和 defer 属性类似，也是会开启一个线程去下载 JavaScript 文件，但和defer 不同的是，它会在下载完成后立刻执行，而不是会等到 DOM 加载完成之后再执行，所以还是有可能会造成阻塞。对多个带有 async 的 JavaScript 文件，它不能像defer 那样保证按顺序执行，它是哪个 JavaScript 文件先下载完就先执行哪个。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>什么时候用 defer，什么时候用 async 呢？</p><p>一般来说，两者之间的选择则是看脚本之间是否有依赖关系，有依赖的话应当要保证执行顺序，应当使用 defer 没有依赖的话使用 async。要注意的是两者都不应该使用 <code>document.write</code>，这个导致整个页面被清除。</p><p>模块化的代码、测试代码或者监听代码使用 async。</p><p>这两个值是布尔类型的，在 HTML 里面只写属性名即可。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://a.com/a.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span></span><br></pre></td></tr></table></figure><p>如果不考虑兼容 IE 浏览器，完全可以将 <code>&lt;script&gt;</code> 放在 <code>&lt;head&gt;</code> 里，同时守设置 defer 属性，这样 HTML 解析的时候，可以并行下载 JavaScript 脚本，等 HTML 页面解析完，JavaScript 脚本在开始执行，充分利用资源。比如查看 gitlab 页面源码。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>defer 是 HTML4 就有的属性，而 async 是 HTML5 新加入的属性。defer 出现的早，IE6 及以上的浏览器基本都支持，可以放心用。 async IE10 就开始支持了，移动端的支持比较好。不考虑 IE 的话，两个属性都可以放心使用。</p><p>兼容性可以点击这里查看<a href="https://caniuse.com" target="_blank" rel="noopener">caniuse</a></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>如果同时设置了 defer 和 async 为 true，浏览器会怎么执行？</p><p>我们做个小实验。</p><p>新建一个文件夹，文件结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── 1.js</span><br><span class="line">├── 2.js</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure><p>1.js 如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>2.js 如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>index.html 的内容如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"./1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"./2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试 async 和 defer <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  alert(3);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置两个 js 是为了排除 async 和 defer 先后顺序的影响。</p><p>FireFox、Chrome、Safari、三个浏览器的执行结构都是 3、1、2，说明同时设置了 defer 和 async 为 true， 以 defer 为准。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html" target="_blank" rel="noopener">async vs defer attributes</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5bcdaed7e51d457a8254e1b7" target="_blank" rel="noopener">网页性能优化之异步加载js文件 - 掘金</a></p><p><a href="https://www.w3.org/TR/html4/interact/scripts.html#18.2.1" target="_blank" rel="noopener">HTML4.1</a></p><p><a href="https://www.w3.org/TR/html51/semantics-scripting.html" target="_blank" rel="noopener">HTML5.1</a></p><p><a href="https://www.w3.org/TR/html53/semantics-scripting.html#element-attrdef-script-defer" target="_blank" rel="noopener">HTML5.3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在 webpack 等工具的照料下，我们忘记了很多的东西，比如说 JavaScript 文件的异步加载，异步执行等等内容。唯一能记起是关于 
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>如何修改 git 已提交的用户邮箱和用户名</title>
    <link href="https://hufangyun.com/2018/git-change-user-info/"/>
    <id>https://hufangyun.com/2018/git-change-user-info/</id>
    <published>2018-09-19T11:44:04.000Z</published>
    <updated>2018-10-02T10:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<img src="https://static.hufangyun.com/hexo/img/git.jpg?imageView2/2/w/600"><h3 id="1、修改上一次提交的邮箱和用户名"><a href="#1、修改上一次提交的邮箱和用户名" class="headerlink" title="1、修改上一次提交的邮箱和用户名"></a>1、修改上一次提交的邮箱和用户名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend --reset-author</span><br></pre></td></tr></table></figure><h3 id="2、批量修改多次提交的邮箱和用户名"><a href="#2、批量修改多次提交的邮箱和用户名" class="headerlink" title="2、批量修改多次提交的邮箱和用户名"></a>2、批量修改多次提交的邮箱和用户名</h3><p>新建一个 <code>shell</code> 脚本 <code>changeGitInfo.sh</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">git filter-branch --env-filter <span class="string">'</span></span><br><span class="line"><span class="string">an="$GIT_AUTHOR_NAME"</span></span><br><span class="line"><span class="string">am="$GIT_AUTHOR_EMAIL"</span></span><br><span class="line"><span class="string">cn="$GIT_COMMITTER_NAME"</span></span><br><span class="line"><span class="string">cm="$GIT_COMMITTER_EMAIL"</span></span><br><span class="line"><span class="string">if [ "$GIT_COMMITTER_EMAIL" = "这里写你原来的邮箱" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">cn="你想替换成的用户名"</span></span><br><span class="line"><span class="string">cm="你想替换成的邮箱"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">if [ "$GIT_AUTHOR_EMAIL" = "这里写你原来的邮箱" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">an="你想替换成的用户名"</span></span><br><span class="line"><span class="string">am="你想替换成的邮箱"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">export GIT_AUTHOR_NAME="$an"</span></span><br><span class="line"><span class="string">export GIT_AUTHOR_EMAIL="$am"</span></span><br><span class="line"><span class="string">export GIT_COMMITTER_NAME="$cn"</span></span><br><span class="line"><span class="string">export GIT_COMMITTER_EMAIL="$cm"</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure><p>在 <code>git</code> 仓库(项目)下运行一下，该脚本即可。</p><h2 id="如果避免上面的问题？"><a href="#如果避免上面的问题？" class="headerlink" title="如果避免上面的问题？"></a>如果避免上面的问题？</h2><p>可以看我的这篇博文 <a href="https://hufangyun.com/2019/multi-git-account/">如何管理多个 git 账号</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;https://static.hufangyun.com/hexo/img/git.jpg?imageView2/2/w/600&quot;&gt;

&lt;h3 id=&quot;1、修改上一次提交的邮箱和用户名&quot;&gt;&lt;a href=&quot;#1、修改上一次提交的邮箱和用户名&quot; class=&quot;h
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>我的技术书单</title>
    <link href="https://hufangyun.com/2018/book-tech-my/"/>
    <id>https://hufangyun.com/2018/book-tech-my/</id>
    <published>2018-07-05T02:49:18.000Z</published>
    <updated>2019-03-08T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🙉 是左耳朵耗子（陈皓） 推荐的书籍<br>📖 是在读的书籍<br>📕 是已读的书籍</p></blockquote><h3 id="专业基础"><a href="#专业基础" class="headerlink" title="专业基础"></a>专业基础</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>算法图解 🙉 📖</p><p>算法 🙉</p><p>算法导论 🙉</p><p>编程珠玑 🙉</p><p>数据结构与算法分析 🙉</p><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>数据库系统概念 🙉</p><p>现代操作系统 🙉</p><p>计算机网络 🙉</p><p>计算机程序的构造和解释 🙉</p><p>编译原理 🙉</p><p>深入理解计算机系统 🙉</p><p>Wireshark 数据包分析实战 🙉</p><p>Unix 高级环境编程 🙉</p><p>Unix 网络编程 第 1 卷 套接口 API 、第 2 卷 进程间通信 🙉</p><p>TCP/IP 详解 卷 I 协议 🙉</p><blockquote><p>如果上面的三本看不懂，可以先看是下面的三本</p></blockquote><p>Linux C 编程一站式学习 🙉</p><p>TCP/IP 网络编程 🙉</p><p>图解 TCP/IP 🙉</p><p>HTTP 权威指南 🙉 📕</p><p>The TCP/IP Guide 🙉</p><h3 id="程序员修养"><a href="#程序员修养" class="headerlink" title="程序员修养"></a>程序员修养</h3><p>重构 改善既有代码的设计 🙉 📕</p><p>修改代码的艺术 🙉</p><p>代码整洁之道 🙉 📕</p><p>程序员的职业素养 🙉</p><p>程序员的思维修炼 📕</p><h3 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h3><h4 id="CSS-类"><a href="#CSS-类" class="headerlink" title="CSS 类"></a>CSS 类</h4><p>CSS世界 📖</p><p>CSS实战手册（第四版）8.4 📕</p><p>CSS权威指南（第三版）8.5</p><p>精通CSS（第2版）8.7</p><h4 id="JavaScript-类"><a href="#JavaScript-类" class="headerlink" title="JavaScript 类"></a>JavaScript 类</h4><p>JavaScript DOM 编程艺术（第二版）</p><p>JavsScript高级程序设计</p><p>编写可维护的JavaScript</p><p>高性能网站建设指南</p><p>深入浅出 React 和 Redux 📖</p><p>你不知道的JavaScript 📖</p><p>ECMAScript 6入门(全彩)</p><p>JavaScript语言精粹</p><p>JavaScript权威指南</p><p>高性能JavaScript</p><p>JavaScript设计模式</p><p>Effective JavaScript:编写高质量JavaScript代码的68个有<br>效方法</p><p>JavaScript框架设计</p><h3 id="UI交互"><a href="#UI交互" class="headerlink" title="UI交互"></a>UI交互</h3><p>写给大家看的设计书 📖</p><p>30天学会绘画</p><p>文字设计的原理</p><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>七周七语言</p><p>Github 上的一份书单：<a href="https://github.com/guanpengchn/awesome-books" target="_blank" rel="noopener">https://github.com/guanpengchn/awesome-books</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;🙉 是左耳朵耗子（陈皓） 推荐的书籍&lt;br&gt;📖 是在读的书籍&lt;br&gt;📕 是已读的书籍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;专业基础&quot;&gt;&lt;a href=&quot;#专业基础&quot; class=&quot;headerlink&quot; title=&quot;专业基础
      
    
    </summary>
    
      <category term="读书" scheme="https://hufangyun.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>从哪里了解 Google Chrome 升级的新特性</title>
    <link href="https://hufangyun.com/2018/chrome-update-know/"/>
    <id>https://hufangyun.com/2018/chrome-update-know/</id>
    <published>2018-06-26T11:36:25.000Z</published>
    <updated>2020-05-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Google-Chrome-canary-dev-beta-stable-4-个版本的区别"><a href="#Google-Chrome-canary-dev-beta-stable-4-个版本的区别" class="headerlink" title="Google Chrome canary dev beta stable 4 个版本的区别"></a>Google Chrome canary dev beta stable 4 个版本的区别</h2><p>** 开发流程是这样的 **</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canary -&gt; dev -&gt; beta -&gt; stable</span><br></pre></td></tr></table></figure><img alt="chrome version" src="https://static.hufangyun.com/hexo/img/chrome-version-diff.jpg?imageView2/2/w/750"><span class="img-alt">chrome version</span><p><code>canary</code> 是最激进的，几乎每天都更新。</p><p><code>stable</code> 是稳定版，是面向普通用户，平均六周更新一次</p><p><code>canary</code> 和 <code>stable</code> 会相差 2 个左右的版本。比如 <code>stable</code> 版本现在（2018年6月26日）是 67，<code>canary</code> 现在是 69。</p><img alt="chrome update" src="https://static.hufangyun.com/hexo/img/chrome-update-time.jpg?imageView2/2/w/750"><span class="img-alt">chrome update</span><h2 id="Chromium-和-Chrome-的区别"><a href="#Chromium-和-Chrome-的区别" class="headerlink" title="Chromium 和 Chrome 的区别"></a>Chromium 和 Chrome 的区别</h2><ul><li><p><code>Chromium</code> 是一个开源的浏览器。 </p></li><li><p><code>Chrome</code> 是基于 <code>Chromium</code> 而来。</p></li><li><p><code>Chromium</code> 更新速度和 <code>canary</code> 是一致的。</p></li><li><p><code>Chromium</code> 作为一个开源项目去掉了一些不开源的东西，比如 <code>Google</code> 的标识和 <code>flash</code> 插件等等。 </p></li></ul><h2 id="从哪里可以看到-Chrome-的更新"><a href="#从哪里可以看到-Chrome-的更新" class="headerlink" title="从哪里可以看到 Chrome 的更新"></a>从哪里可以看到 Chrome 的更新</h2><h3 id="Canary-版"><a href="#Canary-版" class="headerlink" title="Canary 版"></a>Canary 版</h3><p><code>Canary</code> 版 几乎每天都更新，但是没有更新日志。只能通过源码的提交记录查看。<a href="https://chromium.googlesource.com/chromium/src/" target="_blank" rel="noopener">项目地址</a></p><p>然后找到 <code>tags</code> 比如 [<code>69.0.3473.1</code>]</p><p>新页面里点击 <code>log</code> 即可查看每次的提交</p><h2 id="Dev-版"><a href="#Dev-版" class="headerlink" title="Dev 版"></a>Dev 版</h2><p><a href="https://blog.chromium.org/" target="_blank" rel="noopener">https://blog.chromium.org/</a></p><h2 id="Stable-版"><a href="#Stable-版" class="headerlink" title="Stable 版"></a>Stable 版</h2><p><a href="https://chromereleases.googleblog.com/" target="_blank" rel="noopener">https://chromereleases.googleblog.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Google-Chrome-canary-dev-beta-stable-4-个版本的区别&quot;&gt;&lt;a href=&quot;#Google-Chrome-canary-dev-beta-stable-4-个版本的区别&quot; class=&quot;headerlink&quot; title=&quot;Go
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>小猿大圣的设计资源收藏夹</title>
    <link href="https://hufangyun.com/2018/ui-design-get/"/>
    <id>https://hufangyun.com/2018/ui-design-get/</id>
    <published>2018-06-14T11:13:39.000Z</published>
    <updated>2020-01-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://hufangyun.com">小猿大圣</a>的 UI 学习自留地</p></blockquote><h2 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h2><p><a href="https://uigradients.com/" target="_blank" rel="noopener">uigradients</a></p><blockquote><p>获取渐变色的网站</p></blockquote><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><p><a href="https://imgkr.com/" target="_blank" rel="noopener">https://imgkr.com/</a></p><h2 id="让截图更漂亮"><a href="#让截图更漂亮" class="headerlink" title="让截图更漂亮"></a>让截图更漂亮</h2><p>来自码力全开工作室：<a href="https://mp.weixin.qq.com/s/K5_uZEevDYkYIVn4zlLkoA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/K5_uZEevDYkYIVn4zlLkoA</a></p><h2 id="设计工具集合"><a href="#设计工具集合" class="headerlink" title="设计工具集合"></a>设计工具集合</h2><p><a href="https://github.com/phh95/Awesome-design-tools/blob/master/README.md" target="_blank" rel="noopener">https://github.com/phh95/Awesome-design-tools/blob/master/README.md</a></p><h2 id="在线海报制作工具"><a href="#在线海报制作工具" class="headerlink" title="在线海报制作工具"></a>在线海报制作工具</h2><h3 id="搞定设计"><a href="#搞定设计" class="headerlink" title="搞定设计"></a>搞定设计</h3><p><a href="https://www.gaoding.com/" target="_blank" rel="noopener">https://www.gaoding.com/</a></p><h3 id="创客贴"><a href="#创客贴" class="headerlink" title="创客贴"></a>创客贴</h3><p><a href="https://www.chuangkit.com/" target="_blank" rel="noopener">https://www.chuangkit.com/</a></p><h3 id="图怪兽"><a href="#图怪兽" class="headerlink" title="图怪兽"></a>图怪兽</h3><p><a href="https://ue.818ps.com/" target="_blank" rel="noopener">https://ue.818ps.com/</a></p><h3 id="图帮主"><a href="#图帮主" class="headerlink" title="图帮主"></a>图帮主</h3><p><a href="https://www.tubangzhu.com/" target="_blank" rel="noopener">https://www.tubangzhu.com/</a></p><h3 id="懒设计"><a href="#懒设计" class="headerlink" title="懒设计"></a>懒设计</h3><p><a href="https://www.fotor.com.cn/" target="_blank" rel="noopener">https://www.fotor.com.cn/</a></p><h3 id="设计坞"><a href="#设计坞" class="headerlink" title="设计坞"></a>设计坞</h3><p><a href="https://isheji5.com" target="_blank" rel="noopener">https://isheji5.com</a></p><h3 id="码卡"><a href="#码卡" class="headerlink" title="码卡"></a>码卡</h3><p><a href="http://maka.im/" target="_blank" rel="noopener">http://maka.im/</a></p><h3 id="易图"><a href="#易图" class="headerlink" title="易图"></a>易图</h3><p><a href="http://www.egpic.cn/" target="_blank" rel="noopener">http://www.egpic.cn/</a></p><h2 id="设计图"><a href="#设计图" class="headerlink" title="设计图"></a>设计图</h2><h2 id="优灵"><a href="#优灵" class="headerlink" title="优灵"></a>优灵</h2><blockquote><p>收集各种应用的截图 app</p></blockquote><h3 id="sketchappsources"><a href="#sketchappsources" class="headerlink" title="sketchappsources"></a>sketchappsources</h3><p><a href="https://www.sketchappsources.com/" target="_blank" rel="noopener">https://www.sketchappsources.com/</a></p><h3 id="dribbble"><a href="#dribbble" class="headerlink" title="dribbble"></a>dribbble</h3><p><a href="https://dribbble.com/" target="_blank" rel="noopener">https://dribbble.com/</a></p><p><img src="/media/15289473603818.jpg" alt=""></p><h3 id="sketchrepo"><a href="#sketchrepo" class="headerlink" title="sketchrepo"></a>sketchrepo</h3><p><a href="https://sketchrepo.com/" target="_blank" rel="noopener">https://sketchrepo.com/</a></p><p><img src="/media/15289475696821.jpg" alt=""></p><h3 id="uipixels"><a href="#uipixels" class="headerlink" title="uipixels"></a>uipixels</h3><p><a href="http://www.uipixels.com/" target="_blank" rel="noopener">http://www.uipixels.com/</a></p><p><img src="/media/15289475478955.jpg" alt=""></p><h3 id="UI-中国"><a href="#UI-中国" class="headerlink" title="UI 中国"></a>UI 中国</h3><p><a href="http://www.ui.cn/" target="_blank" rel="noopener">http://www.ui.cn/</a></p><h3 id="uplabs"><a href="#uplabs" class="headerlink" title="uplabs"></a>uplabs</h3><p><a href="https://www.uplabs.com/" target="_blank" rel="noopener">https://www.uplabs.com/</a></p><p><img src="/media/15289481019068.jpg" alt=""></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><a href="https://unsplash.com/" target="_blank" rel="noopener">unsplash</a></p><h2 id="素材"><a href="#素材" class="headerlink" title="素材"></a>素材</h2><p><a href="https://huaban.com/" target="_blank" rel="noopener">花瓣网</a></p><p><a href="https://588ku.com/" target="_blank" rel="noopener">千图网</a></p><p><a href="https://mp.weixin.qq.com/s/NuOAuI2jefjhtlU-4noHqQ" target="_blank" rel="noopener">100个免费可商用的插画素材</a></p><p>|&gt; 码力全开文章</p><p><a href="https://www.pinterest.com/" target="_blank" rel="noopener">pinterest</a></p><h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><p><a href="https://www.flaticon.com/" target="_blank" rel="noopener">flaticon</a></p><p><a href="https://mp.weixin.qq.com/s/XMm5-PC0bL0iinqlfsyDpA" target="_blank" rel="noopener">4000+免费可自定义的图标集合</a></p><p><a href="https://illlustrations.co/" target="_blank" rel="noopener">illlustrations</a></p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p><a href="http://chuangzaoshi.com/" target="_blank" rel="noopener">创造狮</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://hufangyun.com&quot;&gt;小猿大圣&lt;/a&gt;的 UI 学习自留地&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;配色&quot;&gt;&lt;a href=&quot;#配色&quot; class=&quot;headerlink&quot; title=&quot;配色&quot;
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>SMART目标成长法</title>
    <link href="https://hufangyun.com/2018/smart-goal/"/>
    <id>https://hufangyun.com/2018/smart-goal/</id>
    <published>2018-05-13T04:26:49.000Z</published>
    <updated>2018-05-13T04:26:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-🔗"><a href="#前言-🔗" class="headerlink" title="前言 🔗"></a>前言 🔗</h2><blockquote><p>目标是很美好的事情，你可能会有许多目标：减肥🏃‍♂️、找到一个更好的工作👔、搬进一个更大的房子🏡（或者更小的房子）、写本小说、学习演奏电吉他🎸、编写一个超级 <code>Rails</code> 应用程序或者完全掌握 <code>Erlang</code>。</p></blockquote><blockquote><p>但是很多目标都是一个模式——崇高的、泛泛的“我希望在某某方面更好”。减肥就是一个最好的例子🌰。</p></blockquote><blockquote><p>大多数人想要更苗条🧜‍♀️（特别是我们这些长时间坐在电脑前的人）。<br>但“我想要苗条”并不是一个非常明确的目标（虽然可能是一个很好的愿景——长期、理想的状态）。</p></blockquote><blockquote><p>你体重需要减多少斤？你仰卧举重准备练多少公斤的？何时完成？你准备控制热量还是增加锻炼？⚽️</p></blockquote><blockquote><p>类似地，说你想“学习 <code>Erlang</code> 是不错，但是这到底是什么意思？想要学到什么程度？想用它来做什么？如何开始？<br>为了帮助你专注于自己的目标，能够更好地实现它，请允许我推荐一种风靡一时的来自于咨询领域的诀窍：使用 <code>SMART</code> 方法实现你的目标。🥇</p></blockquote><p><img src="/media/20160621110804644.png" alt="20160621110804644"><span class="img-alt">20160621110804644</span></p><blockquote><p>图片取自 Google Image</p></blockquote><h2 id="什么是-SMART-💪"><a href="#什么是-SMART-💪" class="headerlink" title="什么是 SMART 💪"></a>什么是 <code>SMART</code> 💪</h2><p><strong><code>SMART</code> 代表具体的、可度量的、可实现的、相关的和时间可控的（Specific, Measurable, Achievable, Relevant, and Time-boxed）</strong></p><h3 id="具体的-✅"><a href="#具体的-✅" class="headerlink" title="具体的 ✅"></a>具体的 ✅</h3><p>首先，一个目标任务应该是具体的。也就是说，只说 “我想学习Erlang” 是不够的。应该把事情具体化，例如“我想要用Erlang编写一个可以动态生成内容的Web服务器”。</p><h3 id="可度量的-⏰"><a href="#可度量的-⏰" class="headerlink" title="可度量的 ⏰"></a>可度量的 ⏰</h3><p>如何知道你何时完成？这一直是我最喜欢问的一个问题。为了努力实现目标任务，不管采用什么方法，你必须能够度量它。</p><p>但是一定要采取稳扎稳打、步步为营的过程。你不能期望一周之内减掉五十英镑或者利用一个周末就学会一门全新的编程语言和它的全部函数库。度量你的目标任务，但是要采取增量进步的方法。👣</p><p>你不必看清你去往何处。不必看清你的目的地和沿途的一切。你只需要看清面前的一两米即可。 </p><h3 id="可实现的👍"><a href="#可实现的👍" class="headerlink" title="可实现的👍"></a>可实现的👍</h3><p>我想要攀登K2峰，想在中东建立永久和平。这一切不会发生。😂</p><p>至少，对我来说是这样。这些都是很好的目标，但是不现实。对我来说在当前的现实情况下无法实现。🤪</p><p>因此，先确定目标是否合理。你也许可以在下周用新语言编写一段 “Hello,World!” 或者一个简单应用，但是你可能无法编写一个完整的Web应用框架和一个带有神经网络优化算法的用户界面构造器。</p><p>从你现在所处的情况着眼，让每一个目标都可实现。🚀</p><h3 id="相关的🔗"><a href="#相关的🔗" class="headerlink" title="相关的🔗"></a>相关的🔗</h3><p>这个目标真的与你有关吗——对你重要吗？🏆你对此有热情吗？是在你控制之下的事情吗？<br>如果不是，这个目标就是不相关的。<br>目标需要相关，需要在你掌控之中🎉。</p><h3 id="时间可控的🕰"><a href="#时间可控的🕰" class="headerlink" title="时间可控的🕰"></a>时间可控的🕰</h3><p>这意味着你需要设定一个最后期限⏱。没有期限，目标会逐步衰退，永远被每天更紧急的事情所排挤。这样它永远都不会实现🥊。</p><p><strong>再强调一遍，稳扎稳打。采取循序渐进、比较细小的里程碑。当实现它们后，你会更有动力去实现下一个里程碑。</strong></p><h2 id="建立SMART任务实现你的目标。⌛️"><a href="#建立SMART任务实现你的目标。⌛️" class="headerlink" title="建立SMART任务实现你的目标。⌛️"></a>建立SMART任务实现你的目标。⌛️</h2><p>这种方法帮助你从自己的角度😀（“我”）、从更积极的角度（“我要”）😘来明确目标，要么用一般现在时，要么给出明确的时间表述（“我会💪在xx时间之前完成zyzzy”）。</p><h2 id="更大背景下的目标🚀"><a href="#更大背景下的目标🚀" class="headerlink" title="更大背景下的目标🚀"></a>更大背景下的目标🚀</h2><p>设定目标是第一步。</p><p>下一步行动是创建小任务以帮助你每天或每隔一段时间都能达到某种程度。你创建的小任务越多，你就越容易看清自己与目标的距离。</p><blockquote><p>本文大部分内容由小猿大圣摘录自 《程序员的思维修炼:开发认知潜能的九堂课 (图灵程序设计丛书)》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言-🔗&quot;&gt;&lt;a href=&quot;#前言-🔗&quot; class=&quot;headerlink&quot; title=&quot;前言 🔗&quot;&gt;&lt;/a&gt;前言 🔗&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;目标是很美好的事情，你可能会有许多目标：减肥🏃‍♂️、找到一个更好的工作👔、搬进一个更
      
    
    </summary>
    
      <category term="读书" scheme="https://hufangyun.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>新手到专家的五个阶段</title>
    <link href="https://hufangyun.com/2018/novice-to-expert-five-stage/"/>
    <id>https://hufangyun.com/2018/novice-to-expert-five-stage/</id>
    <published>2018-05-06T10:48:06.000Z</published>
    <updated>2018-05-06T10:48:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《程序员的思维修炼:开发认知潜能的九堂课 (图灵程序设计丛书)》读书笔记 </p></blockquote><h2 id="德雷福斯模型的5个阶段"><a href="#德雷福斯模型的5个阶段" class="headerlink" title="德雷福斯模型的5个阶段"></a>德雷福斯模型的5个阶段</h2><p><img src="/media/15256037912881.png" alt=""></p><h2 id="有效的使用德雷福斯模型"><a href="#有效的使用德雷福斯模型" class="headerlink" title="有效的使用德雷福斯模型"></a>有效的使用德雷福斯模型</h2><ul><li>需要一个明确定义的任务。 ⏱</li><li>任务需要有适当难度——有挑战性但可行。⏰</li><li>任务环境可以提供大量反馈，以便于你采取行动。🛠</li><li>提供重复犯错和纠正错误的机会。稳步做这种实践十年，你就会达到目标。💯</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;《程序员的思维修炼:开发认知潜能的九堂课 (图灵程序设计丛书)》读书笔记 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;德雷福斯模型的5个阶段&quot;&gt;&lt;a href=&quot;#德雷福斯模型的5个阶段&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="技术成长" scheme="https://hufangyun.com/categories/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>关于转载</title>
    <link href="https://hufangyun.com/2018/copyright-reprinted/"/>
    <id>https://hufangyun.com/2018/copyright-reprinted/</id>
    <published>2018-04-26T08:52:30.000Z</published>
    <updated>2018-04-27T08:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近，发现自己写的博文，被别人转载了。有商业性质的网站、有个人博主，也有各种爬虫自动采集收录。</p><p>比如这篇 <a href="https://hufangyun.com/2017/short-url/">短网址(short URL)系统的原理及其实现</a>, 我发现这篇文章在谷歌和百度搜索的时候，前5、6页搜索结果都找不到我自己的原文地址😭，只有必应第一条搜索结果是我自己的博客 😂</p><h2 id="我不希望文章被复制粘贴转载-❌"><a href="#我不希望文章被复制粘贴转载-❌" class="headerlink" title="我不希望文章被复制粘贴转载 ❌"></a>我不希望文章被复制粘贴转载 ❌</h2><ul><li><strong>我的博客是经常更新的。</strong> 🚀 我的博文是按照更新时间排序的，在编程技术领域以及社会这个大家庭中，我还很年轻，写的东西难免会有错误，或者认知上的不成熟，一旦我发现有错误或者内容补充，我会不定期的更新文章内容。但是复制粘贴转载的文章，并不会随着我更新而更新，错误的内容会一直保留，给之后的阅读者留下隐患。</li><li><strong>我不能更好的收到反馈。</strong> 我发现很多转载的文章下面，有对我文章内容的疑问和勘误，转载文章的人，并不会去解释这些疑问，而我作为文章的原创作者，也收不到别人指正的错误。对文章的阅读者和作者的我，都没有很好的反馈。</li><li><strong>阅读效果不佳。</strong> 最让我受不了的是，我在写作的时候使用了 <code>Markdown</code> 的语法画的流程图很多网站不支持显示，显示的全是代码。还有我用的表情 🐻，他们也显示不出来。。。。</li></ul><h2 id="我希望的转载方式-✅"><a href="#我希望的转载方式-✅" class="headerlink" title="我希望的转载方式 ✅"></a>我希望的转载方式 ✅</h2><p><strong>分享链接转载，指向我的博文。</strong> 我觉的这是最好的转载方式，互赢。</p><p><strong>如果，</strong> 非要复制粘贴的转载，请联系我 <strong>获得授权</strong>，未经许可禁止转载。</p><p>我会在文章的开头注明授权给了谁。我文章更新的时候，也通知转载文章的地方更新。</p><p>邮箱地址：<code>hufy78#gmail.com</code> <code>hufy3651#foxmail.com</code> <code>#</code> 换成 <code>@</code></p><h2 id="关于原创自己总结的方法"><a href="#关于原创自己总结的方法" class="headerlink" title="关于原创自己总结的方法"></a>关于原创自己总结的方法</h2><p>1、有自己的文章风格。这个好像很难。。。</p><p>2、有代码实例，指向自己的网站、Github</p><p>3、图片截图包含自己的博客域名目录等</p><p>4、截图带上自己的水印</p><p>5、每篇文章后面带上转载声明</p><p>6、文章内容示例含有自己的标识</p><h2 id="使用别人的原创"><a href="#使用别人的原创" class="headerlink" title="使用别人的原创"></a>使用别人的原创</h2><p>换位思考，以后我使用别人的图片和摘选的内容时，我会带上来源地址和作者署名，尊重原创。💪</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近，发现自己写的博文，被别人转载了。有商业性质的网站、有个人博主，也有各种爬虫自动采集收录。&lt;/p&gt;
&lt;p&gt;比如这篇 &lt;a href=&quot;https://hufangyun.com/2017/short-url/&quot;&gt;短网址(short URL)系统的原理及其实现&lt;/a&gt;, 
      
    
    </summary>
    
      <category term="随笔" scheme="https://hufangyun.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>效率神器 Alfred workflow 插件推荐</title>
    <link href="https://hufangyun.com/2018/alfred-workflow-recommend/"/>
    <id>https://hufangyun.com/2018/alfred-workflow-recommend/</id>
    <published>2018-04-19T16:38:07.000Z</published>
    <updated>2020-03-19T23:17:07.000Z</updated>
    
    <content type="html"><![CDATA[<img alt="alfred" src="https://static.hufangyun.com/hexo/img/alfred.png?imageView2/2/w/750"><span class="img-alt">alfred</span><blockquote><p>以下是我常用的 Alfred workflow</p></blockquote><p>⚠️ 不同插件，可能有不同作者开发的版本，我推荐的不一定是最好的，只是我一直在用的。比如像有道翻译，可以找到很多版本，选择自己喜欢的即可。</p><blockquote><p>新发现的插件，会添加在最上面的 🎉</p></blockquote><img alt="自用 Alfred Workfolw" src="https://static.hufangyun.com/hexo/img/my-alfred-workflow.png?imageView2/2/w/300"><span class="img-alt">自用 Alfred Workfolw</span><h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><blockquote><p>以下 workflow 按更新排序，新发现的插件会添加在最上面。 🎉<br>点击 ⬇️后的链接，可以直接下载 workflow 文件 。 🚀</p></blockquote><h2 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h2><blockquote><p>切换 SwitchHosts 内配置的 host 文件</p></blockquote><img src="https://static.hufangyun.com/hexo/img/alfred-switchhosts.png?imageView2/2/w/500"><p>🏠 <a href="http://www.packal.org/workflow/switchhosts" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/h3l/douban-workflow/blob/master/douban.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h2 id="豆瓣"><a href="#豆瓣" class="headerlink" title="豆瓣"></a>豆瓣</h2><blockquote><p>查询书籍和电影</p></blockquote><img alt="豆瓣搜索书籍" src="https://static.hufangyun.com/hexo/img/alfred-douban-book.png?imageView2/2/w/500"><span class="img-alt">豆瓣搜索书籍</span><img alt="豆瓣搜索电影" src="https://static.hufangyun.com/hexo/img/alfred-douban-movie.png?imageView2/2/w/500"><span class="img-alt">豆瓣搜索电影</span><p>🏠 <a href="https://github.com/h3l/douban-workflow" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/h3l/douban-workflow/blob/master/douban.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h2 id="豆瓣查询最近上映的电影"><a href="#豆瓣查询最近上映的电影" class="headerlink" title="豆瓣查询最近上映的电影"></a>豆瓣查询最近上映的电影</h2><blockquote><p>通过豆瓣查询正在上映的电影</p></blockquote><img alt="最近上映电影" src="https://static.hufangyun.com/hexo/img/alfred-douban-recent.png?imageView2/2/w/500"><span class="img-alt">最近上映电影</span><p>🏠 <a href="https://github.com/oldmanl/douban-alfred-workflow" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/oldmanl/douban-alfred-workflow/blob/master/douban.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h2 id="豆瓣电影"><a href="#豆瓣电影" class="headerlink" title="豆瓣电影"></a>豆瓣电影</h2><blockquote><p>用于搜索电影的豆瓣评分</p></blockquote><p>第一款</p><img alt="豆瓣搜索电影" src="https://static.hufangyun.com/hexo/img/alfred-douban-movie-3.png?imageView2/2/w/500"><span class="img-alt">豆瓣搜索电影</span><p>🏠 <a href="https://github.com/swim2sun/Douban-Movie-Workflow" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/swim2sun/Douban-Movie-Workflow/blob/master/Douban%20Movie.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><p>第二款</p><p>⚠️ 需要安装 node.js</p><img alt="豆瓣搜索电影" src="https://static.hufangyun.com/hexo/img/alfred-douban-movie-2.png?imageView2/2/w/500"><span class="img-alt">豆瓣搜索电影</span><p>🏠 <a href="https://github.com/sorrycc/alfred-douban" target="_blank" rel="noopener">主页</a></p><h2 id="另一个浏览器打开页面"><a href="#另一个浏览器打开页面" class="headerlink" title="另一个浏览器打开页面"></a>另一个浏览器打开页面</h2><blockquote><p>在另一个浏览器打开当前页面</p></blockquote><p>比如，你在 Chrome 浏览器打开一个页面，如果你想在 Safari 里面打开当前页面，快捷切换。</p><p>🏠 <a href="https://github.com/alexanderhuth/alfred-open-in-browser-workflow" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/alexanderhuth/alfred-open-in-browser-workflow/releases/download/v1.0/openInBrowser.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h3><blockquote><p>控制网易云音乐的播放、下一首、喜欢等需要操作。</p></blockquote><p>🏠 <a href="https://github.com/Ironaki/Netease-Alfred-Controller" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/Ironaki/Netease-Alfred-Controller/blob/master/NeteaseMusicController.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="Fixum"><a href="#Fixum" class="headerlink" title="Fixum"></a>Fixum</h3><blockquote><p>这款 workflow 可以检测其他 workflow 是否有可更新版本，以及处理兼容性问题，只是其他 workflow 的 “医生” 🏥 ️</p></blockquote><img alt="workflow 医生" src="https://static.hufangyun.com/hexo/img/alfred-fixum.jpg?imageView2/2/w/500"><span class="img-alt">workflow 医生</span><p>🏠 <a href="https://github.com/deanishe/alfred-fixum" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/deanishe/alfred-fixum/blob/master/Fixum-0.9.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="ip-查询"><a href="#ip-查询" class="headerlink" title="ip 查询"></a>ip 查询</h3><blockquote><p>查询本机的公网 ip 和局域网 ip</p></blockquote><img alt="ip查询" src="https://static.hufangyun.com/hexo/img/alfred-ip.jpg?imageView2/2/w/500"><span class="img-alt">ip查询</span><p>⬇️ <a href="https://github.com/zenorocha/alfred-workflows/blob/master/ip-address/ip-address.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="快递查询"><a href="#快递查询" class="headerlink" title="快递查询"></a>快递查询</h3><blockquote><p>在 <code>Alfred</code> 中查询快递，使用 <code>kd</code> 关键字，可以记录已经查过的快递和查询新快递，不需要输入快递公司名称。</p></blockquote><img alt="快递查询" src="https://static.hufangyun.com/hexo/img/alfred-express.jpg?imageView2/2/w/500"><span class="img-alt">快递查询</span><p>🏠 <a href="https://github.com/roylez/alfred_kuaidi" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/roylez/alfred_kuaidi/releases/download/v1.5/kuaidi.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="锁定屏幕"><a href="#锁定屏幕" class="headerlink" title="锁定屏幕"></a>锁定屏幕</h3><p>最近同事介绍的，是 <code>alfred</code> 自带的功能，不需要付费即可使用。</p><img src="https://static.hufangyun.com/hexo/img/alfred-lock.jpg?imageView2/2/w/500"><h3 id="http-status-code"><a href="#http-status-code" class="headerlink" title="http status code"></a>http status code</h3><blockquote><p>显示 http 状态码含义</p></blockquote><img src="https://static.hufangyun.com/hexo/img/alfred-http.jpg?imageView2/2/w/500"><p>第一款</p><p>🏠 <a href="https://github.com/JoelQ/alfred-http" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/JoelQ/alfred-http/releases/download/v0.1.0/HTTP.Statuses.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><p>第二款</p><p>🏠 <a href="https://github.com/Dreamseer/alfred-http" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/Dreamseer/alfred-http/blob/master/http-status.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="codeVar"><a href="#codeVar" class="headerlink" title="codeVar"></a>codeVar</h3><blockquote><p>生成变量名<br>作为一名开发者，我超级 😍 这款 workflow</p></blockquote><p>支持大小驼峰、常量、下划线</p><img src="https://static.hufangyun.com/hexo/img/alfred-var.jpg?imageView2/2/w/500"><p>🏠 <a href="https://github.com/xudaolong/CodeVar" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/xudaolong/CodeVar/blob/master/CodeVar.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h3><blockquote><p>颜色转换工具</p></blockquote><p>⚠️ 需要安装 <code>node.js</code> 环境</p><img src="https://static.hufangyun.com/hexo/img/alfred-color.jpg?imageView2/2/w/500"><p>🏠 <a href="https://github.com/TylerEich/Alfred-Extras" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/TylerEich/Alfred-Extras/releases/download/v1.41/Colors.v1.41.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="Currency-Convert"><a href="#Currency-Convert" class="headerlink" title="Currency Convert"></a>Currency Convert</h3><blockquote><p>汇率转换</p></blockquote><img src="https://static.hufangyun.com/hexo/img/alfred-currency.jpg?imageView2/2/w/500"><p>🏠 <a href="https://github.com/jin5354/alfred3-workflow-CurrencyConvert" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/jin5354/alfred3-workflow-CurrencyConvert/releases/download/v1.5/Currency.Convert.v1.5.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h3><blockquote><p>和 macOS 上的 Dash 软件配合使用，文档搜索</p></blockquote><p>就不上截图了。</p><p>🏠 <a href="https://github.com/Kapeli/Dash-Alfred-Workflow" target="_blank" rel="noopener">主页</a></p><h3 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h3><blockquote><p>搜索表情</p></blockquote><p>第一款</p><img src="https://static.hufangyun.com/hexo/img/alfred-emoji.jpg?imageView2/2/w/500"><ul><li>常用的表情会放在最上面，但是使用的关键词匹配，经常搜不出自己想要的表情</li><li>好处是开箱即用，而下面一款，需要安装 <code>node.js</code> 环境。</li></ul><p>🏠 <a href="https://github.com/carlosgaldino/alfred-emoji-workflow" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/carlosgaldino/alfred-emoji-workflow/blob/master/package/emoji-codes.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><p>第二款</p><img src="https://static.hufangyun.com/hexo/img/alfred-emoji-npm.jpg?imageView2/2/w/500"><ul><li>搜索结果会把相关的表情都展示出来，不只是关键词匹配。</li><li><code>node.js</code> 开发的，需要安装一些必要的环境。</li></ul><p>🏠 <a href="https://github.com/sindresorhus/alfred-emoj" target="_blank" rel="noopener">主页</a></p><h3 id="Encode-Decode"><a href="#Encode-Decode" class="headerlink" title="Encode/Decode"></a>Encode/Decode</h3><blockquote><p>编码解码工具</p></blockquote><img src="https://static.hufangyun.com/hexo/img/alfred-encode.jpg?imageView2/2/w/500"><p>🏠 <a href="https://github.com/willfarrell/alfred-encode-decode-workflow" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/willfarrell/alfred-encode-decode-workflow/blob/master/encode-decode.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><blockquote><p>快速查找项目、用户</p></blockquote><img src="https://static.hufangyun.com/hexo/img/alfred-github.jpg?imageView2/2/w/500"><p>🏠 <a href="https://github.com/gharlan/alfred-github-workflow" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/gharlan/alfred-github-workflow/releases/download/v1.6.2/github.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab"></a>Gitlab</h3><blockquote><p>快速搜索并打开项目，支持自定义域名的 gitlab</p></blockquote><img src="https://static.hufangyun.com/hexo/img/alfred-gitlab.jpg?imageView2/2/w/500"><p>🏠 <a href="https://github.com/lukewaite/alfred-gitlab" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/lukewaite/alfred-gitlab/blob/master/GitLab.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><p>默认配置的是 <a href="https://gitlab.com/explore" target="_blank" rel="noopener"><code>gitlab</code></a>, 也可以设置公司的 <code>gitlab</code></p><p>输入 <code>glseturl</code> 空格后，输入地址。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//&lt;host&gt;/api/v4/projects</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// host 换成自己公司的</span></span><br></pre></td></tr></table></figure><p>如果发现部分项目搜索不到，可以使用以下命令清除缓存</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">gl workflow:delcache</span><br></pre></td></tr></table></figure><h3 id="nameBeta"><a href="#nameBeta" class="headerlink" title="nameBeta"></a>nameBeta</h3><blockquote><p>基于 namebata.com 的查询域名是否注册的工具<br>我自己写的，developing</p></blockquote><img src="https://static.hufangyun.com/hexo/img/alfred-namebeta.jpg?imageView2/2/w/500"><p>🏠 <a href="https://github.com/Youthink/alfred-namebeta-workflow" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/Youthink/alfred-namebeta-workflow/blob/master/alfred-namebeta.com-workflow.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><blockquote><p>搜索 npm 包</p></blockquote><img src="https://static.hufangyun.com/hexo/img/alfred-node.jpg?imageView2/2/w/500"><p>🏠 <a href="https://github.com/onvno/alfred-package-workflow" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/onvno/alfred-package-workflow/blob/master/package/node.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="Package-Managers"><a href="#Package-Managers" class="headerlink" title="Package Managers"></a>Package Managers</h3><blockquote><p>上面的插件只能搜索 npm 包，这个就强大了 <code>yarn</code> <code>npm</code> <code>yo</code> <code>brew</code> <code>apt-get</code> <code>composer</code> <code>docker</code> <code>gems</code> <code>gradle</code> <code>hex</code> <code>maven</code> <code>pypi</code> 等等，很多语言以及工具的包都可以搜索。</p></blockquote><p>🏠 <a href="https://github.com/willfarrell/alfred-pkgman-workflow" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/willfarrell/alfred-pkgman-workflow/blob/master/Package%20Managers.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="Search-Evernote-Chinese-Edition"><a href="#Search-Evernote-Chinese-Edition" class="headerlink" title="Search Evernote (Chinese Edition)"></a>Search Evernote (Chinese Edition)</h3><blockquote><p>搜索印象笔记</p></blockquote><img src="https://static.hufangyun.com/hexo/img/alfred-yinxiang.png?imageView2/2/w/500"><p>🏠 <a href="https://github.com/patricorgi/alfred-evernote" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/patricorgi/alfred-evernote/blob/master/Search%20Evernote%20(Chinese%20Edition).alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="timestamp-helper"><a href="#timestamp-helper" class="headerlink" title="timestamp-helper"></a>timestamp-helper</h3><blockquote><p>时间戳转换</p></blockquote><img src="https://static.hufangyun.com/hexo/img/alfred-timestamp.jpg?imageView2/2/w/500"><p>🏠 <a href="http://www.packal.org/workflow/timestamp" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/packal/repository/raw/master/com.jousch.alfred.timestamp/timestamp.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="有道翻译"><a href="#有道翻译" class="headerlink" title="有道翻译"></a>有道翻译</h3><blockquote><p>单词、句子翻译，支持发音</p></blockquote><img src="https://static.hufangyun.com/hexo/img/alfred-youdao.jpg?imageView2/2/w/500"><p>🏠 <a href="https://github.com/whyliam/whyliam.workflows.youdao" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/whyliam/whyliam.workflows.youdao/blob/master/whyliam.workflows.youdao.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="Open-with-MacVim"><a href="#Open-with-MacVim" class="headerlink" title="Open with MacVim"></a>Open with MacVim</h3><blockquote><p>使用 MacVim 打开文件</p></blockquote><img src="https://static.hufangyun.com/hexo/img/alfred-macvim.jpg?imageView2/2/w/500"><p>🏠 <a href="https://github.com/franzheidl/alfred-workflows/tree/master/open-with-macvim" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/franzheidl/alfred-workflows/blob/master/open-with-macvim/Open%20with%20MacVim.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="AlfredHiddenFilesToggle"><a href="#AlfredHiddenFilesToggle" class="headerlink" title="AlfredHiddenFilesToggle"></a>AlfredHiddenFilesToggle</h3><blockquote><p>macOS 显示隐藏文件</p></blockquote><p>🏠 <a href="https://github.com/logic1988/AlfredHiddenFilesToggle" target="_blank" rel="noopener">主页</a></p><p>⬇️ <a href="https://github.com/logic1988/AlfredHiddenFilesToggle/blob/master/Hidden%20Files%20Toggle.alfredworkflow" target="_blank" rel="noopener">下载地址</a></p><h2 id="插件搜索"><a href="#插件搜索" class="headerlink" title="插件搜索"></a>插件搜索</h2><blockquote><p>可以在这三个地方寻找插件</p></blockquote><ul><li><p><a href="http://www.packal.org/" target="_blank" rel="noopener">packal</a></p></li><li><p><a href="http://www.alfredworkflow.com/" target="_blank" rel="noopener">alfredworkflow</a></p></li><li><p><a href="https://github.com" target="_blank" rel="noopener">Github</a></p></li></ul><p><strong>本文会时常更新，❤️ 的话，可以收藏一下。</strong></p><blockquote><p>欢迎来<a href="https://hufangyun.com">我的博客</a>评论交流，爬虫那么多，评论在其他地方我可能看不到 😂</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img alt=&quot;alfred&quot; src=&quot;https://static.hufangyun.com/hexo/img/alfred.png?imageView2/2/w/750&quot;&gt;&lt;span class=&quot;img-alt&quot;&gt;alfred&lt;/span&gt;

&lt;blockquote
      
    
    </summary>
    
      <category term="最热" scheme="https://hufangyun.com/categories/%E6%9C%80%E7%83%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>我的技术成长历程-2017</title>
    <link href="https://hufangyun.com/2018/tech-road-my-2017/"/>
    <id>https://hufangyun.com/2018/tech-road-my-2017/</id>
    <published>2018-02-04T04:20:45.000Z</published>
    <updated>2018-02-04T18:34:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><blockquote><p>2017年我离开校园，从实习到转正，算是正式参加工作了。我希望以后每年回顾的时候，都能感受到自己的技术成长。我也想练就一身的武艺，在IT的江湖里，仗剑天涯。</p></blockquote><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p>2017年我学习了新语言 <code>elixir</code> (文末的扩展阅读有介绍的链接) 以及其对应的 web 框架 <code>phoenix</code> 。 <code>elixir</code> + <code>phoenix</code> 有点类似于 <code>ruby</code> on <code>rails</code> 。<code>phoenix</code> 配套的工具比较齐全，开发应用的体验很棒。上手后，感觉写 web 应用效率很高，能够快速的构建原型，验证自己的 ideas。这算是扩展自己服务端的技术栈，完善自己 web 领域的知识结构。</p><p>第二个，现在养成了，查看源码，溯本求源，刨根问底的习惯。<br>以前遇到问题时候，先 <code>Google</code> 是肯定的了，开发者必备的技能嘛。但是如果搜索的时候解决不了的问题，我也会去问答类的网站寻求帮助。但是2017年，我又 Get 了一个新的技能，查看源码。我发现很多的问题，尤其是很多前端库导致的问题，看一遍源码，不但问题解决了，而且对该库的实现也会有个大概的了解。有时候有些小伙伴也会向我请教问题，初看的话，我也不知道怎么解决。但是当我去翻看源码的时候，很多问题就迎刃而解了。这也是编程初学者快速提高实力的一个方法。</p><p>第三个，<code>markdown</code> 的书写格式。<br>自从看了 <code>markdown</code> 的一些书写规范后，我在用 <code>markdown</code> 写文档的时候格式注意多了。我觉的以后我要把这种好的习惯延续到我的代码规范里，保持一点代码洁癖。</p><p>第四个，文章的推广。<br>之前我一直在 <a href="https://segmentfault.com/u/youthink" target="_blank" rel="noopener">segmentfault</a> 上写技术博文(因为他们家的 markdown 编辑器很好用)，后来有一次我把自己的 <a href="https://hufangyun.com/2017/short-url/">短网址(short URL)系统的原理及其实现</a> 这篇分享到了掘金，一周之内我博客的流量暴增，超乎我的想象力，让我发现了新世界。文章收到好的反馈，对我来说是很积极的鼓励，让我再接再厉。</p><h3 id="晋升"><a href="#晋升" class="headerlink" title="晋升"></a>晋升</h3><p>年底一件很高兴的事情就是，老大帮我提名晋升，结果也很棒，晋升成功。职称晋升算是对我的技术成长最好的反馈。再接再厉，做好技术沉淀，挑战下一个技术等级。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://hufangyun.com/2017/elixir-introduction/">elixir介绍：未来的编程语言</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2017&quot;&gt;&lt;a href=&quot;#2017&quot; class=&quot;headerlink&quot; title=&quot;2017&quot;&gt;&lt;/a&gt;2017&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;2017年我离开校园，从实习到转正，算是正式参加工作了。我希望以后每年回顾的时候，都能感受到自己的
      
    
    </summary>
    
      <category term="技术成长" scheme="https://hufangyun.com/categories/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>使用 edeliver 部署 Elixir 应用程序</title>
    <link href="https://hufangyun.com/2017/elixir-edeliver/"/>
    <id>https://hufangyun.com/2017/elixir-edeliver/</id>
    <published>2017-12-10T16:00:00.000Z</published>
    <updated>2019-11-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<img src="https://static.hufangyun.com/hexo/img/elixir-deploy.png?imageView2/2/w/600"><blockquote><p>最近使用 <code>Elixir</code> 的 web 框架 <code>Phoenix</code> 开发了一个简单的应用，部署的时候踩了不少坑。做一下笔记。</p></blockquote><blockquote><p>elixir 1.9.x 之后部署上略有改变，更新一下。 </p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="第一步：引入-edeliver-依赖"><a href="#第一步：引入-edeliver-依赖" class="headerlink" title="第一步：引入 edeliver 依赖"></a>第一步：引入 edeliver 依赖</h3><p>修改 <code>mix.exs</code> 文件，引入 <a href="https://github.com/edeliver/edeliver" target="_blank" rel="noopener">edeliver</a> 依赖</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span></span>, <span class="symbol">do:</span> [</span><br><span class="line">  <span class="symbol">extra_applications:</span> [</span><br><span class="line">    ...</span><br><span class="line">    <span class="symbol">:edeliver</span></span><br><span class="line">  ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">defp</span> <span class="title">deps</span></span> <span class="keyword">do</span></span><br><span class="line">  [</span><br><span class="line">    ...</span><br><span class="line">    &#123;<span class="symbol">:edeliver</span>, <span class="string">"&gt;= 1.7.0"</span>&#125;,</span><br><span class="line">    &#123;<span class="symbol">:distillery</span>, <span class="string">"~&gt; 2.1"</span>, <span class="symbol">warn_missing:</span> <span class="keyword">false</span>&#125;,</span><br><span class="line">  ]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="第二步：生成配置文件"><a href="#第二步：生成配置文件" class="headerlink" title="第二步：生成配置文件"></a>第二步：生成配置文件</h3><p>执行 <code>mix distillery.init</code> 生成 <code>rel</code> 配置文件夹，里面的配置默认即可。</p><p><code>Phoenix</code> 框架做了一些变更，<code>config/prod.secret.exs</code> 也加入到了版本控制里，因为敏感数据都是从系统环境变量里取了。</p><h4 id="edeliver-配置"><a href="#edeliver-配置" class="headerlink" title="edeliver 配置"></a>edeliver 配置</h4><p>在项目文件夹，创建 <code>.deliver/config</code> 文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">APP=<span class="string">"your-erlang-app"</span> <span class="comment"># 应用名称</span></span><br><span class="line"></span><br><span class="line">BUILD_HOST=<span class="string">"build-system.acme.org"</span> <span class="comment"># 构建的主机地址</span></span><br><span class="line">BUILD_USER=<span class="string">"build"</span> <span class="comment"># 构建主机的登录用户名</span></span><br><span class="line"></span><br><span class="line">BUILD_AT=<span class="string">"/tmp/erlang/my-app/builds"</span> <span class="comment"># 构建主机上的构建文件夹</span></span><br><span class="line"></span><br><span class="line">STAGING_HOSTS=<span class="string">"test1.acme.org test2.acme.org"</span> <span class="comment"># 测试主机地址</span></span><br><span class="line">STAGING_USER=<span class="string">"test"</span> <span class="comment"># 测试主机的登录用户名</span></span><br><span class="line">TEST_AT=<span class="string">"/test/my-erlang-app"</span> <span class="comment"># 测试的构建文件夹</span></span><br><span class="line"></span><br><span class="line">PRODUCTION_HOSTS=<span class="string">"deploy1.acme.org deploy2.acme.org"</span> <span class="comment"># 部署主机地址</span></span><br><span class="line">PRODUCTION_USER=<span class="string">"production"</span> <span class="comment"># 部署主机的登录用户名</span></span><br><span class="line">DELIVER_TO=<span class="string">"/opt/my-erlang-app"</span> <span class="comment"># 部署的文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的这一段其实不需要了，敏感数据都是从系统环境变量里取了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pre_erlang_get_and_update_deps() &#123;</span></span><br><span class="line"><span class="comment">#  local _prod_secret_path="/home/builder/prod.secret.exs"</span></span><br><span class="line"><span class="comment">#  if [ "$TARGET_MIX_ENV" = "prod" ]; then</span></span><br><span class="line"><span class="comment">#    __sync_remote "</span></span><br><span class="line"><span class="comment">#      ln -sfn '$_prod_secret_path' '$BUILD_AT/config/prod.secret.exs'</span></span><br><span class="line"><span class="comment">#   "</span></span><br><span class="line"><span class="comment">#  fi</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure><p>举个例子 🌰 我某次的配置文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">APP=<span class="string">"habit"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动以 git revision 作为发布名称</span></span><br><span class="line">AUTO_VERSION=<span class="string">"revision"</span></span><br><span class="line"></span><br><span class="line">BUILD_HOST=<span class="string">"url"</span></span><br><span class="line">BUILD_USER=<span class="string">"web"</span></span><br><span class="line">BUILD_AT=<span class="string">"/tmp/edeliver/habit/builds"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我只有正式环境，所以没有配置 STAGING 环境</span></span><br><span class="line">PRODUCTION_HOSTS=<span class="string">"url"</span></span><br><span class="line">PRODUCTION_USER=<span class="string">"web"</span></span><br><span class="line"></span><br><span class="line">DELIVER_TO=<span class="string">"/home/web/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 换用了国内的源，加快依赖安装速度</span></span><br><span class="line">HEX_MIRROR_URL=<span class="string">"https://hexpm.upyun.com"</span></span><br></pre></td></tr></table></figure><p>配置好后，执行以下命令。每次构建的压缩包，不记录到 <code>git</code> 记录里</p><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">echo <span class="string">".deliver/releases/"</span> <span class="meta">&gt;&gt; </span>.gitignore</span><br></pre></td></tr></table></figure><p>提交刚才配置文件的修改，并且下载依赖编译</p><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span> -A &amp;&amp; git commit -m <span class="string">"Setting up edeliver"</span></span><br><span class="line">mix <span class="keyword">do</span> deps.<span class="keyword">get</span>, compile</span><br></pre></td></tr></table></figure><h3 id="第三步：配置项目"><a href="#第三步：配置项目" class="headerlink" title="第三步：配置项目"></a>第三步：配置项目</h3><p><code>config/prod.exs</code> 部署配置添加一下内容</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">http:</span> <span class="string">[port:</span> <span class="number">26</span><span class="string">_000],</span></span><br><span class="line"><span class="attr">load_from_system_env:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">server:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="第四步：配置环境变量"><a href="#第四步：配置环境变量" class="headerlink" title="第四步：配置环境变量"></a>第四步：配置环境变量</h3><p>前面说了，现在敏感信息都从服务器的系统变量中取，我们把以下变量配置到 <code>~/.profile</code> 文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export SECRET_KEY_BASE='b8qq2J2a7YBNwwoL91Y2BpG/AJSaG0uOqy9JA7Cy+D1tWZKuSiLNXRblfSwNV/7e'</span><br><span class="line">export PORT=26000</span><br><span class="line">export POOL_SIZE=10</span><br><span class="line">export DATABASE_URL='ecto://USER:PASSWORD@HOST/DATABASE'</span><br></pre></td></tr></table></figure><p>根据自己的项目替换以上变量。</p><p><code>SECRET_KEY_BASE</code> 是使用 <code>mix phx.gen.secret</code> 命令生成的，在本地的项目执行一下，粘贴过来即可。</p><p>创建好数据库后，就可以使用以下命令启动发布应用</p><h3 id="第五步：配置数据库"><a href="#第五步：配置数据库" class="headerlink" title="第五步：配置数据库"></a>第五步：配置数据库</h3><p><code>phoenix</code> 默认使用的 <code>postgreSQL</code> 数据库</p><p>切换到默认用户 <code>postgres</code></p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo su - postgres</span></span><br></pre></td></tr></table></figure><p>进入数据库</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">psql</span></span><br></pre></td></tr></table></figure><p>创建用户并赋予权限</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> www <span class="keyword">WITH</span> <span class="keyword">PASSWORD</span> <span class="string">'u867#eDgg6#2@elo098OIUh'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> habit_prod OWNER www;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">role</span> www login createdb;</span><br></pre></td></tr></table></figure><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>现在使用以下命令创建线上数据库的数据表</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mix</span> edeliver migrate production</span><br></pre></td></tr></table></figure><h3 id="第六步：部署"><a href="#第六步：部署" class="headerlink" title="第六步：部署"></a>第六步：部署</h3><h4 id="edeliver-基本命令"><a href="#edeliver-基本命令" class="headerlink" title="edeliver 基本命令"></a>edeliver 基本命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">其他的配置可以参考 [项目文档](https://github.com/edeliver/edeliver)</span><br><span class="line"></span><br><span class="line">```glsl</span><br><span class="line">mix edeliver update production --start-deploy # 发布应用并启动</span><br><span class="line"></span><br><span class="line">--branch=dev 指定使用 dev 分支 默认使用的 master</span><br><span class="line"></span><br><span class="line">--verbose 部署的时候打印详细的信息</span><br><span class="line"></span><br><span class="line">mix edeliver ping production # 查看应用是否正在运行</span><br><span class="line">mix edeliver upgrade  # 升级应用</span><br><span class="line"></span><br><span class="line">mix edeliver version production # 查看应用的版本</span><br><span class="line">mix edeliver migrate production # 运行数据库构建 执行该命令前要先部署应用</span><br><span class="line">mix edeliver restart production # 或者 start 或者 stop</span><br></pre></td></tr></table></figure><h4 id="migrate-数据库迁移命令"><a href="#migrate-数据库迁移命令" class="headerlink" title="migrate 数据库迁移命令"></a>migrate 数据库迁移命令</h4><p>🔔 <strong>注意</strong>  执行以下的命令之前，要先部署应用。</p><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mix</span> edeliver migrate production  <span class="meta"># 运行数据库构建</span></span><br><span class="line"><span class="built_in">mix</span> edeliver migrate production up <span class="meta"># 同上面的命令</span></span><br><span class="line"><span class="built_in">mix</span> edeliver migrate production down <span class="meta"># 逆向执行数据库构建 会删除所有的数据表和数据</span></span><br><span class="line"><span class="built_in">mix</span> edeliver show migrations production <span class="meta"># 执行上面的 down 命令后会显示状态</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>如果不幸，发布出现问题。可以在一下目录查看日志</p><p>配置文件里的 <code>DELIVER_TO=&quot;/home/web/&quot;</code> 就是我们项目的部署目录，对应的日志文件也在这里。比如我的：<code>/home/web/habit/log</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f erlang.log.1</span><br></pre></td></tr></table></figure><h3 id="查看端口使用"><a href="#查看端口使用" class="headerlink" title="查看端口使用"></a>查看端口使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -i :80</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tlunp</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -anp|grep 80</span><br></pre></td></tr></table></figure><h2 id="可能会用到的文章"><a href="#可能会用到的文章" class="headerlink" title="可能会用到的文章"></a>可能会用到的文章</h2><p><a href="https://devato.com/automate-elixir-phoenix-1-4-deployment-with-distillery-and-edeliver-on-ubuntu/" target="_blank" rel="noopener">Elixir Phoenix 1.4 Deployments with Distillery and Edeliver on Ubuntu</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;https://static.hufangyun.com/hexo/img/elixir-deploy.png?imageView2/2/w/600&quot;&gt;

&lt;blockquote&gt;
&lt;p&gt;最近使用 &lt;code&gt;Elixir&lt;/code&gt; 的 web 框架 &lt;c
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>linux 服务器初始化配置流程</title>
    <link href="https://hufangyun.com/2017/linux-init/"/>
    <id>https://hufangyun.com/2017/linux-init/</id>
    <published>2017-12-08T16:00:00.000Z</published>
    <updated>2019-11-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/819542712-5a291b0bb9615_articlex.jpeg" alt="819542712-5a291b0bb9615_articlex"><span class="img-alt">819542712-5a291b0bb9615_articlex</span></p><blockquote><p>开发 <code>web</code> 应用的时候，经常需要配置服务器。我在阮一峰老师的 <a href="http://www.ruanyifeng.com/blog/2014/03/server_setup.html" target="_blank" rel="noopener">Linux服务器的初步配置流程</a> 的基础上，整理了这篇笔记。节约以后配置服务器的时间。 </p></blockquote><h2 id="修改-root-密码"><a href="#修改-root-密码" class="headerlink" title="修改 root 密码"></a>修改 root 密码</h2><p><code>root</code> 账户默认没有密码 安全起见 先初始化一个</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><h2 id="创建-Linux-管理员账户"><a href="#创建-Linux-管理员账户" class="headerlink" title="创建 Linux 管理员账户"></a>创建 Linux 管理员账户</h2><blockquote><p>🐧 使用 <code>Linux</code> 服务器的时候，尽量不要使用 <code>root</code> 账号，处理日常操作，我们新建一个管理员账号。</p></blockquote><p>首先，添加一个用户组（这里我自定义的 admin）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addgroup admin</span><br></pre></td></tr></table></figure><p>然后，添加一个新用户（假定为 www）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd -d /home/www -s /bin/bash -m www</span><br></pre></td></tr></table></figure><p>上面命令中，参数 <code>d</code> 指定用户的主目录，参数 <code>s</code> 指定用户的 <code>shell</code>，参数 <code>m</code> 表示如果该目录不存在，则创建该目录。</p><p>接着，设置新用户的密码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd www</span><br></pre></td></tr></table></figure><p>将新用户（www）添加到用户组（admin）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usermod -a -G admin www</span><br></pre></td></tr></table></figure><p>接着，为新用户设定sudo权限。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/sudoers</span><br></pre></td></tr></table></figure><p>找到下面这一行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root    ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>在这一行的下面，再添加一行。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line">www    ALL=(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><p>上面的 <code>NOPASSWD</code> 表示，切换 sudo 的时候，不需要输入密码。如果出于安全考虑，也可以强制要求输入密码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root    ALL=(ALL:ALL) ALL</span><br><span class="line">www    ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>最后，先退出 <code>root</code> 用户登录，再用新用户的身份登录。</p><h2 id="配置-SSH-服务"><a href="#配置-SSH-服务" class="headerlink" title="配置 SSH 服务"></a>配置 SSH 服务</h2><p>把自己电脑的 <code>ssh</code> 公钥，保存到服务器的 <code>~/.ssh/authorized_keys</code> 文件中</p><p>直接使用下面的命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 默认端口 22</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@123.456.78</span><br><span class="line"></span><br><span class="line">// 带端口 25000</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub -p 25000 root@123.456.78</span><br></pre></td></tr></table></figure><p>本地电脑配置 ssh config</p><p>修改 <code>~/.ssh/config</code> 文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Host 字段后面的名称自定义</span><br><span class="line">Host day-root</span><br><span class="line">  hostname 132.111.111.111</span><br><span class="line">  port 25000</span><br><span class="line">  user root</span><br><span class="line"></span><br><span class="line">Host day</span><br><span class="line">  hostname 132.111.111.111</span><br><span class="line">  port 25000</span><br><span class="line">  user www</span><br></pre></td></tr></table></figure><p>之后 <code>ssh day</code> 无须输入密码，就可以登入服务器了。</p><p>然后，进入服务器，编辑SSH配置文件/etc/ssh/sshd_config。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/ssh/sshd_config ~     (备份，复原时使用)</span><br><span class="line">sudo vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>在配置文件中，将 SSH 的默认端口 22 改掉。假设使用 25000</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Port 25000</span><br></pre></td></tr></table></figure><p>然后，检查几个设置是否设成下面这样，确保去除前面的#号。</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>Protocol 2</td><td>ssh 协议使用新版的</td></tr><tr><td>PermitRootLogin no</td><td>不允许 root 登录</td></tr><tr><td>PermitEmptyPasswords no</td><td>不允许空密码登录</td></tr><tr><td>PasswordAuthentication no</td><td>使用密码授权登录</td></tr><tr><td>GSSAPIAuthentication no</td><td>加快连接</td></tr><tr><td>PubkeyAuthentication yes</td><td>允许公钥认证</td></tr><tr><td>UseDNS no</td><td>禁用DNS反向解析 会加快速度</td></tr><tr><td>SyslogFacility AUTHPRIV</td><td>记录用户登录信息</td></tr></tbody></table><p>上面主要是禁止 <code>root</code> 用户登录，以及禁止用密码方式登录。</p><p>保存后，退出文件编辑。</p><p>接着，改变authorized_keys文件的权限。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod 600 ~/.ssh/authorized_keys &amp;&amp; chmod 700 ~/.ssh/</span><br></pre></td></tr></table></figure><p>重启 SSHD</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><h2 id="运行环境配置"><a href="#运行环境配置" class="headerlink" title="运行环境配置"></a>运行环境配置</h2><p>检查服务器的区域设置。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locale</span><br></pre></td></tr></table></figure><p>如果结果不是 <code>en_US.UTF-8</code>，建议都设成它。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo locale-gen en_US en_US.UTF-8 en_CA.UTF-8</span><br><span class="line">sudo dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><p>然后，更新软件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p>最后，再根据需要，做一些安全设置，比如搭建防火墙，关闭 <code>HTTP</code>、<code>HTTPs</code>、<code>SSH</code> 以外的端口，详细可参考这篇 <a href="http://spenserj.com/blog/2013/07/15/securing-a-linux-server/" target="_blank" rel="noopener">《Securing a Linux Server》</a>。</p><h2 id="设置时区"><a href="#设置时区" class="headerlink" title="设置时区"></a>设置时区</h2><p>使用 tzselect 命令选择需要的时区。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tzselect</span><br></pre></td></tr></table></figure><p>设置完后，命令行会提示我们将时区的配置文件添加到 <code>.profile</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TZ='Asia/Hong_Kong'; export TZ</span><br></pre></td></tr></table></figure><p>执行完后，重新登录系统或者刷新 <code>~/.bashrc</code> 文件使其生效</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>更改 Linux 整个系统范围的时区可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><p>现在使用 <code>date</code> 命令查看一下时间。</p><h2 id="特别番"><a href="#特别番" class="headerlink" title="特别番"></a>特别番</h2><h3 id="阿里云服务器"><a href="#阿里云服务器" class="headerlink" title="阿里云服务器"></a>阿里云服务器</h3><p>阿里云服务器可以在控制台设置安全组规则。</p><h4 id="什么是安全组"><a href="#什么是安全组" class="headerlink" title="什么是安全组"></a>什么是安全组</h4><p>简单点，给大家举个栗子🌰，我部署了一个 <code>MongoDB</code> 的数据库，我怕别人黑我数据库，我就可以在安全组的规则里设置 <code>公网入方向</code> 拒绝访问 <code>MongoDB</code> 使用的端口 <code>27017</code>。只允许本地 <code>locahost</code> 访问，禁止公网访问。</p><p>下面是教科书版具体解释</p><p>阿里云产品介绍 请看这里 <a href="https://www.alibabacloud.com/help/zh/doc-detail/25387.htm" target="_blank" rel="noopener">安全组</a></p><blockquote><p>安全组是一种虚拟防火墙，具备状态检测包过滤功能。安全组用于设置单台或多台云服务器的网络访问控制，它是重要的网络安全隔离手段，用于在云端划分安全域。</p></blockquote><blockquote><p>安全组是一个逻辑上的分组，这个分组是由同一个地域（Region）内具有相同安全保护需求并相互信任的实例组成。每个实例至少属于一个安全组，在创建的时候就需要指定。同一安全组内的实例之间网络互通，不同安全组的实例之间默认内网不通。可以授权两个安全组之间互访。</p></blockquote><h3 id="腾讯云服务器"><a href="#腾讯云服务器" class="headerlink" title="腾讯云服务器"></a>腾讯云服务器</h3><p>默认账户是 ubuntu，初始密码是自己设置的。忘记的话可以重置密码。</p><p>修改 root 密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>切换用户</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su www</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ruanyifeng.com/blog/2014/03/server_setup.html" target="_blank" rel="noopener">Linux服务器的初步配置流程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/819542712-5a291b0bb9615_articlex.jpeg&quot; alt=&quot;819542712-5a291b0bb9615_articlex&quot;&gt;&lt;span class=&quot;img-alt&quot;&gt;819542712-5a291b0bb9
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>短网址(short URL)系统的原理及其实现</title>
    <link href="https://hufangyun.com/2017/short-url/"/>
    <id>https://hufangyun.com/2017/short-url/</id>
    <published>2017-11-09T11:00:35.000Z</published>
    <updated>2019-10-02T10:32:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅授权过： <code>segmentfault</code> 转载</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>提供一个短址服务<br>你有没有发现，我们的任务中出现长 URL 就会比较麻烦？如果有一个短址生成器就好了。虽然市面上有很多，但是我们可以重复发明一个轮子，利用这个机会尝试一下简单的 Web 全栈开发。</p></blockquote><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>做一个短链接生成器，可以将一个长链接缩短成一个短链接。 </p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><blockquote><p>由 <a href="https://gigalixir.com/" target="_blank" rel="noopener">Gigalixir</a> 提供免费部署服务，该地址只用于体验，⚠️ 不提供数据维护存储。</p></blockquote><p><a href="https://fearless-trustworthy-aidi.gigalixirapp.com/" target="_blank" rel="noopener">体验地址</a></p><h2 id="要发车了-🚌"><a href="#要发车了-🚌" class="headerlink" title="要发车了 🚌"></a>要发车了 🚌</h2><p>发车前，和大家说一下</p><p>如果不想重复的造轮子，想开箱即用，可以使用基于 <code>PHP</code> 的开源软件 <a href="https://github.com/YOURLS/YOURLS" target="_blank" rel="noopener">YOURLS</a>。<code>YOURLS</code> 还可以和 <code>WordPress</code> 整合到一起，功能强大，可扩展性高。</p><blockquote><p>本文记录了开发短网址系统的整个过程，包括初期的算法调研、模块设计、数据库设计、功能扩展等。</p></blockquote><h2 id="什么是短链接-🔗"><a href="#什么是短链接-🔗" class="headerlink" title="什么是短链接 🔗"></a>什么是短链接 🔗</h2><blockquote><p>就是把普通网址，转换成比较短的网址。比如：<a href="http://t.cn/RlB2PdD" target="_blank" rel="noopener">http://t.cn/RlB2PdD</a> 这种，在微博这些限制字数的应用里。好处不言而喻。短、字符少、美观、便于发布、传播。 </p></blockquote><p>百度短网址 <a href="http://dwz.cn/" target="_blank" rel="noopener">http://dwz.cn/</a><br>谷歌短网址服务 <a href="https://goo.gl/" target="_blank" rel="noopener">https://goo.gl/</a> （需科学上网）号称是最快的 🚀</p><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>当我们在浏览器里输入 <a href="http://t.cn/RlB2PdD" target="_blank" rel="noopener">http://t.cn/RlB2PdD</a> 时</p><ol><li>DNS首先解析获得 <a href="http://t.cn" target="_blank" rel="noopener">http://t.cn</a> 的 <code>IP</code> 地址</li><li>当 <code>DNS</code> 获得 <code>IP</code> 地址以后（比如：74.125.225.72），会向这个地址发送 <code>HTTP</code> <code>GET</code> 请求，查询短码 <code>RlB2PdD</code></li><li><a href="http://t.cn" target="_blank" rel="noopener">http://t.cn</a> 服务器会通过短码 <code>RlB2PdD</code> 获取对应的长 URL</li><li>请求通过 <code>HTTP</code> <code>301</code> 转到对应的长 URL <a href="https://m.helijia.com" target="_blank" rel="noopener">https://m.helijia.com</a> 。</li></ol><p>这里有个小的知识点，为什么要用 301 跳转而不是 302 呐？</p><blockquote><p>301 是永久重定向，302 是临时重定向。短地址一经生成就不会变化，所以用 301 是符合 <code>http</code> 语义的。同时对服务器压力也会有一定减少。<br>但是如果使用了 <code>301</code>，我们就无法统计到短地址被点击的次数了。而这个点击次数是一个非常有意思的大数据分析数据源。能够分析出的东西非常非常多。所以选择302虽然会增加服务器压力，但是我想是一个更好的选择。 </p></blockquote><blockquote><p>来自知乎 iammutex 的<a href="https://www.zhihu.com/question/29270034/answer/46446911" target="_blank" rel="noopener">答案</a></p></blockquote><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>网上比较流行的算法有两种 自增序列算法、 摘要算法</p><h3 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h3><p><strong>自增序列算法</strong> 也叫永不重复算法</p><p>设置 id 自增，一个 10进制 id 对应一个 62进制的数值，1对1，也就不会出现重复的情况。这个利用的就是低进制转化为高进制时，字符数会减少的特性。</p><p>如下图：十进制 10000，对应不同进制的字符表示。 </p><img src="https://static.hufangyun.com/hexo/img/short-url.png?imageView2/2/w/300"><p>短址的长度一般设为 6 位，而每一位是由 <code>[a - z, A - Z, 0 - 9]</code> 总共 62 个字母组成的，所以 6 位的话，总共会有 62^6 ~= 568亿种组合，基本上够用了。</p><p>哈哈，这里附上一个进制转换工具 <a href="http://tool.lu/hexconvert/" target="_blank" rel="noopener">http://tool.lu/hexconvert/</a> 上图的数据就是用这个工具生成的。</p><p>具体的算法实现，自行谷歌。</p><h3 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h3><ol><li>将长网址 <code>md5</code> 生成 32 位签名串,分为 4 段, 每段 8 个字节</li><li>对这四段循环处理, 取 8 个字节, 将他看成 16 进制串与 0x3fffffff(30位1) 与操作, 即超过 30 位的忽略处理</li><li>这 30 位分成 6 段, 每 5 位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串</li><li>总的 <code>md5</code> 串可以获得 4 个 6 位串,取里面的任意一个就可作为这个长 url 的短 url 地址</li></ol><p>这种算法,虽然会生成4个,但是仍然存在重复几率</p><h3 id="两种算法对比"><a href="#两种算法对比" class="headerlink" title="两种算法对比"></a>两种算法对比</h3><p>第一种算法的好处就是简单好理解，永不重复。但是短码的长度不固定，随着 id 变大从一位长度开始递增。如果非要让短码长度固定也可以就是让 id 从指定的数字开始递增就可以了。百度短网址用的这种算法。上文说的开源短网址项目 <code>YOURLS</code> 也是采用了这种算法。<a href="https://github.com/YOURLS/YOURLS/blob/master/includes/functions.php" target="_blank" rel="noopener">源码学习</a></p><p>第二种算法，存在碰撞（重复）的可能性，虽然几率很小。短码位数是比较固定的。不会从一位长度递增到多位的。据说微博使用的这种算法。</p><p>我使用的算法一。有一个不太好的地方就是出现的短码是有序的，可能会不安全。我的处理方式是构造 62进制的字母不要按顺序排列。因为想实现自定义短码的功能，我又对算法一进行了优化，下文会介绍。</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h3 id="自增序列算法流程图"><a href="#自增序列算法流程图" class="headerlink" title="自增序列算法流程图"></a>自增序列算法流程图</h3><div id="flowchart-0" class="flow-chart"></div><blockquote><p>只实现长链接转化为短链接的功能，不是很麻烦。在调研的过程中我发现<a href="https://www.dwz.cn" target="_blank" rel="noopener">百度短网址</a>可以自定义短码，我觉的这个功能挺不错，结果复杂度就是上图到下图的变化。😭</p></blockquote><h3 id="自增序列算法-用户自定义短码-流程图"><a href="#自增序列算法-用户自定义短码-流程图" class="headerlink" title="自增序列算法 + 用户自定义短码 流程图"></a>自增序列算法 + 用户自定义短码 流程图</h3><div id="flowchart-1" class="flow-chart"></div><p>百度短网址还允许用户自定义短码，算法二 摘要算法，不和 id 绑定，好像挺好实现这个功能的。</p><p>但是自增序列算法是和 id 绑定的，如果允许自定义短码就会占用之后的短码，之后的 id 要生成短码的时候就发现短码已经被用了，那么 id 自增一对一不冲突的优势就体现不出来了。</p><p><strong>那么怎么实现自定义短码呐？</strong></p><p>我是这样处理的：</p><blockquote><p>数据库增加一个类型 type 字段，用来标记短码是用户自定义生成的，还是系统自动生成的。<br>如果有用户自定义过短码，把它的类型标记自定义。每次根据 id 计算短码的时候，如果发现对应的短码被占用了，就从类型为自定义的记录里选取一条记录，用它的 id 去计算短码。<br>这样既可以区分哪些长连接是用户自己定义还是系统自动生成的，还可以不浪费被自定义短码占用的 id</p></blockquote><p>我保留了 1 到 2 位的 短码，从三位的短码开始生成的。就像域名的保留域名一样，好的要自己预留 😏 </p><table><thead><tr><th>位数</th><th>个数</th><th>区间</th></tr></thead><tbody><tr><td>1位</td><td>62</td><td>0 - 61</td></tr><tr><td>2位</td><td>3844</td><td>62 - 3843</td></tr><tr><td>3位</td><td>约 23万</td><td>3844 - 238327</td></tr><tr><td>4位</td><td>约 1400万</td><td>238328 - 14776335</td></tr><tr><td>5位</td><td>约 9.1亿</td><td>14776336 - 916132831</td></tr><tr><td>6位</td><td>约 568亿</td><td>916132832 - 56800235583</td></tr></tbody></table><h3 id="数据表设计"><a href="#数据表设计" class="headerlink" title="数据表设计"></a>数据表设计</h3><p>links 表</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>link_id</td></tr><tr><td>url</td><td>长连接</td></tr><tr><td>keyword</td><td>短链接码</td></tr><tr><td>type</td><td>系统: “system” 自定义: “custom”</td></tr><tr><td>insert_at</td><td>插入时间</td></tr><tr><td>updated_at</td><td>更新时间</td></tr></tbody></table><h2 id="后期功能扩展"><a href="#后期功能扩展" class="headerlink" title="后期功能扩展"></a>后期功能扩展</h2><p>统计：点击量、访问的 ip 地域、用户使用的设备</p><p>管理后台：删除、数据量</p><p>登录：权限管理</p><p>设置密码：输入密码才可以继续访问</p><h2 id="项目源码"><a href="#项目源码" class="headerlink" title="项目源码"></a>项目源码</h2><p>使用 Elixir + phoenix 技术栈 <a href="https://github.com/Youthink/short_url" target="_blank" rel="noopener">short_url</a> </p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始e=>end: 结束io1=>inputoutput: 输入网址io2=>inputoutput: 返回短网址op1=>operation: 返回对应的短码op2=>operation: 保存输入的网址到数据库op3=>operation: 根据id计算对应的短码op4=>operation: 更新短码到数据库cond1=>condition: 查询数据库是否存在对应的短码st->io1->cond1cond1(no,bottom)->op2->op3->op4->op1->io2->econd1(yes)->op1->io2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: 开始e=>end: 结束io1=>inputoutput: 输入网址io2=>inputoutput: 返回短网址io3=>inputoutput: 提示用户该短码已存在io4=>inputoutput: 提示用户不能输入短链接op1=>operation: 返回短码op2=>operation: 保存输入的网址到数据库op3=>operation: 根据id计算对应的短码op4=>operation: 查询数据库获得一条自定义短码的url对应的id记录op5=>operation: 更新短码到数据库cond1=>condition: 查询数据库是否存在该URLcond2=>condition: 用户选择自定义短码cond3=>condition: 生成的短码是否存在cond4=>condition: 短码是否存在cond5=>condition: 短码是否存在cond6=>condition: 自定义的短码是否存在cond7=>condition: 用户输入的是短链接st->io1->cond7cond7(no,bottom)->cond1cond7(yes)->io4->econd1(no,bottom)->cond2cond1(yes)->op1->io2->econd2(no,bottom)->op3->cond4cond2(yes)->cond5cond4(no, bottom)->op5->op1->io2->econd4(yes)->op4->op3->cond4cond5(no,bottom)->op5cond5(yes)->io3->e</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文仅授权过： &lt;code&gt;segmentfault&lt;/code&gt; 转载&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;提供一个短址服务&lt;br&gt;你
      
    
    </summary>
    
      <category term="最热" scheme="https://hufangyun.com/categories/%E6%9C%80%E7%83%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>一次掌握 JavaScript ES5 到 ES8 数组内容</title>
    <link href="https://hufangyun.com/2017/array-learn/"/>
    <id>https://hufangyun.com/2017/array-learn/</id>
    <published>2017-10-30T23:46:39.000Z</published>
    <updated>2018-05-13T23:46:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/array.jpg" alt="array"><span class="img-alt">array</span></p><p>图片来源：<a href="https://github.com/tooto1985/js-array-operations" target="_blank" rel="noopener">Yi-Tai Lin</a></p><p>本文仅授权过： <code>前端早读课</code> 转载</p><h2 id="ECMAScript-5-1-中提供的数组方法"><a href="#ECMAScript-5-1-中提供的数组方法" class="headerlink" title="ECMAScript 5.1 中提供的数组方法"></a>ECMAScript 5.1 中提供的数组方法</h2><p>其中部分方法，ECMAScript 3 就出现了，但是本文不再细分。</p><p><a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.4" target="_blank" rel="noopener">ECMA-262/5.1 规范</a></p><h4 id="判断是否是数组"><a href="#判断是否是数组" class="headerlink" title="判断是否是数组"></a>判断是否是数组</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray ( arg )</span><br><span class="line"><span class="comment">// false or true</span></span><br></pre></td></tr></table></figure><p>不支持此方法的IE9-等浏览器可以这样处理：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br></pre></td></tr></table></figure><h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p>数组的 <code>valueOf</code> 会默认调用 <code>toString</code> 方法，所以他们的返回值一样，都是逗号分隔每一项组成的字符串</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> months = [<span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>];</span><br><span class="line">months.toString(); <span class="comment">// "Jan,Feb,Mar,Apr"</span></span><br></pre></td></tr></table></figure><h4 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString"></a>toLocaleString</h4><p>调用数组每一项的 <code>toLocaleString</code> 方法，有时和 <code>toString</code> 方法的结果是一样的。有时也不同，比如 <code>Date</code> 对象元素组成的数组里，返回的结果会不同。</p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a.join();      <span class="comment">// 'Wind,Rain,Fire'</span></span><br><span class="line">a.join(<span class="string">', '</span>);  <span class="comment">// 'Wind, Rain, Fire'</span></span><br><span class="line">a.join(<span class="string">' + '</span>); <span class="comment">// 'Wind + Rain + Fire'</span></span><br><span class="line">a.join(<span class="string">''</span>);    <span class="comment">// 'WindRainFire'</span></span><br></pre></td></tr></table></figure><p>如果数组中的某一项的值是 <code>null</code> 或者 <code>undefined</code>，那么该值在 <code>join()</code>、<code>toLocale-String()</code>、<code>toString()</code> 和 <code>valueOf()</code> 方法返回的结果中以空字符串表示</p><p>对应的逆向方法是 <code>String.split()</code></p><h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><h4 id="pop-删除数组的最后一项"><a href="#pop-删除数组的最后一项" class="headerlink" title="pop 删除数组的最后一项"></a>pop 删除数组的最后一项</h4><p>操作原数组，返回删除项</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.pop();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="push-在数组末尾添加新元素"><a href="#push-在数组末尾添加新元素" class="headerlink" title="push 在数组末尾添加新元素"></a>push 在数组末尾添加新元素</h4><p>操作的原数组，返回数组长度</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.push(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><h4 id="shift-删除数组的第一项"><a href="#shift-删除数组的第一项" class="headerlink" title="shift 删除数组的第一项"></a>shift 删除数组的第一项</h4><p>操作的原数组，返回删除项</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.shift();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="unshift-数组的前面添加新元素"><a href="#unshift-数组的前面添加新元素" class="headerlink" title="unshift 数组的前面添加新元素"></a>unshift 数组的前面添加新元素</h4><p>操作的原数组，返回数组长度</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.unshift(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// [4, 5, 1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><h4 id="reverse-反转数组项的顺序"><a href="#reverse-反转数组项的顺序" class="headerlink" title="reverse 反转数组项的顺序"></a>reverse 反转数组项的顺序</h4><p>操作原数组，返回数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>];</span><br><span class="line"><span class="keyword">var</span> b= a.reverse();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ['three', 'two', 'one']</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// ['three', 'two', 'one']</span></span><br></pre></td></tr></table></figure><h4 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort 排序"></a>sort 排序</h4><p>按照 Unicode code 位置排序，默认升序</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fruit = [<span class="string">'cherries'</span>, <span class="string">'apples'</span>, <span class="string">'bananas'</span>];</span><br><span class="line">fruit.sort(); <span class="comment">// ['apples', 'bananas', 'cherries']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scores = [<span class="number">1</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">2</span>];</span><br><span class="line">scores.sort(); <span class="comment">// [1, 10, 2, 21]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// because '10' is mix of two characters '1' and '0' so '10' is before '2' in Unicode code point order.</span></span><br></pre></td></tr></table></figure><p>排序后 <code>undefined</code> 会被放在数组末尾</p><p>之前写过一篇排序方法的深入解读，感兴趣请点击这里</p><p><a href="https://segmentfault.com/a/1190000010648740" target="_blank" rel="noopener">深入浅出 JavaScript 的 Array.prototype.sort 排序算法</a></p><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="concat-合并数组"><a href="#concat-合并数组" class="headerlink" title="concat 合并数组"></a>concat 合并数组</h4><p>返回新数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.concat(arr2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br><span class="line"><span class="comment">// expected output: ["a", "b", "c", "d", "e", "f"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr4 = arr1.concat(<span class="number">1</span>, [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(arr4);</span><br><span class="line"><span class="comment">//猜猜这个的结果？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： ['a', 'b', 'c', 1, 4, [5, 6]]</span></span><br><span class="line"><span class="comment">//如果传入的是数组，取的是其值。但是数组中的数组，是保留的。</span></span><br></pre></td></tr></table></figure><h4 id="slice-基于当前数组创建新数组"><a href="#slice-基于当前数组创建新数组" class="headerlink" title="slice 基于当前数组创建新数组"></a>slice 基于当前数组创建新数组</h4><p>返回新数组</p><p>传入两个参数 起始位置（包含） 结束位置（不包含），虎头蛇尾，有始无终。</p><p>只传一个参数默认截取到数组末尾, 会认为是开始位置</p><p>传递的参数中有一个负数，则用数组长度加上该数来确定位置。长度为 5 的数组 <code>slice（-2，-1）</code> 与 <code>slice（3, 4）</code> 结果相同。</p><p>结束位置小于起始位置，则返回空数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>];</span><br><span class="line"><span class="keyword">var</span> sliced = a.slice(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);      <span class="comment">// ['1', '2', '3', '4']</span></span><br><span class="line"><span class="built_in">console</span>.log(sliced); <span class="comment">// ['2', '3']</span></span><br></pre></td></tr></table></figure><h4 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h4><p>可以实现 删除、插入（元素个数大于要删除的元素个数）、替换（删除一个，再添加一个）</p><p>返回被删除元素组成的数组，如果没有被删除元素，返回空数组</p><p>参数： 起始位置(包含)、要删除的元素个数、元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFish = [<span class="string">'angel'</span>, <span class="string">'clown'</span>, <span class="string">'mandarin'</span>, <span class="string">'sturgeon'</span>];</span><br><span class="line"></span><br><span class="line">myFish.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'drum'</span>);</span><br><span class="line"><span class="comment">// ["angel", "clown", "drum", "mandarin", "sturgeon"]</span></span><br><span class="line"></span><br><span class="line">myFish.splice(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// ["angel", "clown", "mandarin", "sturgeon"]</span></span><br><span class="line"></span><br><span class="line">myFish.splice(<span class="number">-1</span>, <span class="number">0</span>, <span class="string">'drum'</span>);</span><br><span class="line"><span class="comment">//["angel", "clown", "mandarin", "drum", "sturgeon"]</span></span><br></pre></td></tr></table></figure><p>区别于 <code>concat</code> 如果插入数组，就会插入数组，而不是将数组拆开。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myFish.splice(<span class="number">2</span>, <span class="number">1</span>, [<span class="string">"hello"</span>, <span class="string">"world"</span>]);</span><br><span class="line"><span class="comment">// ["angel", "clown", ["hello", "world"], "sturgeon"]</span></span><br></pre></td></tr></table></figure><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p><code>indexOf</code> 和 <code>lastIndexOf</code> 都接受两个参数：查找的值、查找起始位置</p><p>不存在，返回 -1 ；存在，返回位置。<code>indexOf</code> 是从前往后查找， <code>lastIndexOf</code> 是从后往前查找。</p><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>, <span class="number">9</span>, <span class="number">9</span>];</span><br><span class="line">a.indexOf(<span class="number">2</span>); <span class="comment">// 0</span></span><br><span class="line">a.indexOf(<span class="number">7</span>); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a.indexOf(<span class="number">7</span>) === <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// element doesn't exist in array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>];</span><br><span class="line">numbers.lastIndexOf(<span class="number">2</span>);     <span class="comment">// 3</span></span><br><span class="line">numbers.lastIndexOf(<span class="number">7</span>);     <span class="comment">// -1</span></span><br><span class="line">numbers.lastIndexOf(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 3</span></span><br><span class="line">numbers.lastIndexOf(<span class="number">2</span>, <span class="number">2</span>);  <span class="comment">// 0</span></span><br><span class="line">numbers.lastIndexOf(<span class="number">2</span>, <span class="number">-2</span>); <span class="comment">// 0</span></span><br><span class="line">numbers.lastIndexOf(<span class="number">2</span>, <span class="number">-1</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>ECMAScript 5 提供了5个迭代方法，他们的参数都是</p><p>给定的函数(当前元素、位置、数组)</p><p>可选的，执行回调是的 this 值</p><h4 id="every"><a href="#every" class="headerlink" title="every"></a>every</h4><p>对数组的每一项都运行给定的函数，每一项都返回 ture,则返回 true</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &lt; <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>].every(isBigEnough);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="some"><a href="#some" class="headerlink" title="some"></a>some</h4><p>对数组的每一项都运行给定的函数，任意一项返回 ture,则返回 true</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBiggerThan10</span>(<span class="params">element, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt; <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].some(isBiggerThan10);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].some(isBiggerThan10); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> words = [<span class="string">"spray"</span>, <span class="string">"limit"</span>, <span class="string">"elite"</span>, <span class="string">"exuberant"</span>, <span class="string">"destruction"</span>, <span class="string">"present"</span>, <span class="string">"happy"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> longWords = words.filter(<span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> word.length &gt; <span class="number">6</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Filtered array longWords is ["exuberant", "destruction", "present"]</span></span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>对数组的每一项都运行给定的函数，返回每次函数调用的结果组成一个新数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">var</span> doubles = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// doubles is now [2, 10, 20, 30]</span></span><br><span class="line"><span class="comment">// numbers is still [1, 5, 10, 15]</span></span><br></pre></td></tr></table></figure><h4 id="forEach-数组遍历"><a href="#forEach-数组遍历" class="headerlink" title="forEach 数组遍历"></a>forEach 数组遍历</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [<span class="string">'item1'</span>, <span class="string">'item2'</span>, <span class="string">'item3'</span>];</span><br><span class="line"><span class="keyword">const</span> copy = [];</span><br><span class="line"></span><br><span class="line">items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">  copy.push(item)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="缩小方法"><a href="#缩小方法" class="headerlink" title="缩小方法"></a>缩小方法</h3><p>reduce、reduceRight 一个是从前往后遍历，一个是从后往前遍历，比上面的五个迭代方法回调函数多了一个参数：上一项的值</p><p>回调函数参数(累加器返回的值、当前元素、当前的位置、数组) 初始值</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" target="_blank" rel="noopener">MDN reduce</a></p><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = numbers.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// expected output: 6</span></span><br></pre></td></tr></table></figure><p><strong>实战例子</strong></p><p>将数组转化成所需格式的对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  &#123;<span class="attr">envName</span>: <span class="string">'stg'</span>, <span class="attr">cpu</span>: <span class="number">4</span>, <span class="attr">memory</span>: <span class="number">2</span>&#125;, </span><br><span class="line">  &#123;<span class="attr">envName</span>: <span class="string">'pre'</span>, <span class="attr">cpu</span>: <span class="number">2</span>, <span class="attr">memory</span>: <span class="number">4</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> newObj = arr.reduce(<span class="function">(<span class="params">acc, o</span>) =&gt;</span> &#123;</span><br><span class="line">  acc[o.envName] = &#123;</span><br><span class="line">    cpu: o.cpu,</span><br><span class="line">    memory: o.memory</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"stg"</span>: &#123;</span><br><span class="line">    <span class="string">"cpu"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">"memory"</span>: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"pre"</span>: &#123;</span><br><span class="line">    <span class="string">"cpu"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">"memory"</span>: <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight"></a>reduceRight</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.concat(b);</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// flattened is [4, 5, 2, 3, 0, 1]</span></span><br></pre></td></tr></table></figure><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>队列方法和栈方法操作的都是原数组，增加数组元素的时候，返回值是数组长度；删除数组元素的时候，返回值是被删除的元素。</p><h4 id="哪些方法改变了原数组？"><a href="#哪些方法改变了原数组？" class="headerlink" title="哪些方法改变了原数组？"></a>哪些方法改变了原数组？</h4><p>栈方法：push、pop</p><p>队列方法：shift、unshift</p><p>重排序方法：reverse、sort</p><p>操作方法：splice</p><h4 id="哪些方法返回的是数组？"><a href="#哪些方法返回的是数组？" class="headerlink" title="哪些方法返回的是数组？"></a>哪些方法返回的是数组？</h4><p>重排序方法：reverse、sort</p><p>操作方法：splice、slice、concat</p><p>迭代方法中：filter、map</p><h2 id="ECMAScript-6-0-新增的方法"><a href="#ECMAScript-6-0-新增的方法" class="headerlink" title="ECMAScript 6.0 新增的方法"></a>ECMAScript 6.0 新增的方法</h2><p><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-array-objects" target="_blank" rel="noopener">ECMA-262/6.0 规范</a></p><h4 id="from"><a href="#from" class="headerlink" title="from"></a>from</h4><p>将类似数组的对象（array-like object）和可遍历（iterable）的对象转为真正的数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="built_in">Array</span>.from(bar);</span><br><span class="line"><span class="comment">// ["a", "b", "c"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">'foo'</span>);</span><br><span class="line"><span class="comment">// ["f", "o", "o"]</span></span><br></pre></td></tr></table></figure><h4 id="of"><a href="#of" class="headerlink" title="of"></a>of</h4><p>用于将一组值，转换为数组</p><p>这个方法的主要目的，是弥补数组构造函数 <code>Array()</code> 的不足。因为参数个数的不同，会导致 <code>Array()</code> 的行为有差异。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">7</span>);       <span class="comment">// [7]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">7</span>);          <span class="comment">// [ , , , , , , ]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h4 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin"></a>copyWithin</h4><p>将指定位置的元素复制到其他位置（会覆盖原有元素），返回当前数组。该方法会修改当前数组。</p><p>它接受三个参数。</p><ul><li>target（必需）：从该位置开始替换数据。</li><li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li><li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-2</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 1, 2]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 3, 4]</span></span><br></pre></td></tr></table></figure><h4 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h4><p>使用给定值，填充一个数组。</p><p>会抹除数组原有的元素</p><p>还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">numbers.fill(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// results in [1, 1, 1]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// ['a', 7, 'c']</span></span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>找出第一个符合条件的数组元素，参数是一个回调函数，所有数组元素依次执行该回调函数，直到找出第一个返回值为 <code>true</code> 的元素，然后返回该元素。如果没有符合条件的元素，则返回 <code>undefined</code>。回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h4 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h4><p><code>findIndex</code> 方法的用法与 <code>find</code> 方法非常类似，返回第一个符合条件的数组元素的位置，如果所有元素都不符合条件，则返回 -1。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><blockquote><p>ES6 提供三个新的方法—— entries()，keys()和 values() —— 用于遍历数组。它们都返回一个遍历器对象，可以用 for…of 循环进行遍历，唯一的区别是 keys() 是对键名的遍历、values() 是对键值的遍历，entries() 是对键值对的遍历。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br></pre></td></tr></table></figure><h4 id="entries"><a href="#entries" class="headerlink" title="entries"></a>entries</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = a.entries();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure><h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = arr.keys();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h4 id="values"><a href="#values" class="headerlink" title="values"></a>values</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">'w'</span>, <span class="string">'y'</span>, <span class="string">'k'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = a.values();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// w</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// y</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// k</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// o</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value); <span class="comment">// p</span></span><br></pre></td></tr></table></figure><p>更多使用方式，可以参考 <a href="http://es6.ruanyifeng.com/#docs/array" target="_blank" rel="noopener">阮一峰 ECMAScript 6入门</a></p><h2 id="ECMAScript-7-0-新增的方法"><a href="#ECMAScript-7-0-新增的方法" class="headerlink" title="ECMAScript 7.0 新增的方法"></a>ECMAScript 7.0 新增的方法</h2><p><a href="https://www.ecma-international.org/ecma-262/7.0/#sec-properties-of-the-array-prototype-object" target="_blank" rel="noopener">ECMA-262/7.0 规范</a></p><h4 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h4><p>判断数组中是否存在该元素</p><p>参数：查找的值、起始位置</p><p>可以替换 ES5 时代的 <code>indexOf</code> 判断方式</p><p><code>indexOf</code> 判断元素是否为 <code>NaN</code>，会判断错误</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = [1, 2, 3];</span><br><span class="line">a.includes(2); // true</span><br><span class="line">a.includes(4); // false</span><br></pre></td></tr></table></figure><p><a href="https://www.ecma-international.org/ecma-262/8.0/index.html#sec-array-objects" target="_blank" rel="noopener">ECMA-262/8.0 规范</a></p><p>ES8 没增加数组方法</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>JavaScript 高级程序设计</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">MDN web docs</a></p><p><a href="http://es6.ruanyifeng.com/#docs/array" target="_blank" rel="noopener">阮一峰 ECMAScript 6入门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/array.jpg&quot; alt=&quot;array&quot;&gt;&lt;span class=&quot;img-alt&quot;&gt;array&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;图片来源：&lt;a href=&quot;https://github.com/tooto1985/js-array-ope
      
    
    </summary>
    
      <category term="最热" scheme="https://hufangyun.com/categories/%E6%9C%80%E7%83%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>【随用随查】PostgreSQL 实践笔记</title>
    <link href="https://hufangyun.com/2017/sql-postgres/"/>
    <id>https://hufangyun.com/2017/sql-postgres/</id>
    <published>2017-10-30T14:24:45.000Z</published>
    <updated>2019-12-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文记录了 <code>PostgreSQL</code> 基本操作，入门的 <code>SQL</code> 语句以及高阶的联表查询等内容。本文自用，时常更新。<code>PostgreSQL</code> 和 <code>MySQL</code> 的 <code>SQL</code> 语句基本相同，应该选择哪个？可以参考文末的<a href="#扩展阅读">扩展阅读</a>。</p></blockquote><img src="https://static.hufangyun.com/hexo/img/sql-postgresql.png?imageView2/2/w/600"><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://pg.sjk66.com/" target="_blank" rel="noopener">PostgreSQL轻松学</a></p><p><a href="http://www.w3school.com.cn/sql/sql_func_format.asp" target="_blank" rel="noopener">w3schoolSQL教程</a></p><p><a href="https://www.postgresql.org/docs/9.6/static/reference.html" target="_blank" rel="noopener">PostgreSQL 英文文档</a></p><p><a href="http://wiki.jikexueyuan.com/project/sql/" target="_blank" rel="noopener">极客学院SQL教程</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p><code>macOS</code> 上可以使用 <code>brew</code> 安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install postgres</span><br></pre></td></tr></table></figure><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install postgresql-11</span><br></pre></td></tr></table></figure><p>查看状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status postgresql</span><br></pre></td></tr></table></figure><p>切换用户</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo -i -u postgres</span><br><span class="line">psql</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="http://blog.everlose.com/mac-homebrew-postgresql.html" target="_blank" rel="noopener">Mac 下使用 homebrew 安装 postgresql 及配置</a> </p><h5 id="mac-启动-postgreSQL-服务"><a href="#mac-启动-postgreSQL-服务" class="headerlink" title="mac 启动 postgreSQL 服务"></a>mac 启动 postgreSQL 服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pg_ctl -D /usr/local/var/postgres start</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务在后台运行</span></span><br><span class="line">brew services start postgresql</span><br></pre></td></tr></table></figure><h5 id="连接远程数据库"><a href="#连接远程数据库" class="headerlink" title="连接远程数据库"></a>连接远程数据库</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">psql -h IP或者主机地址 -p 端口 -U 用户 -d 数据库</span><br><span class="line"></span><br><span class="line">psql -h 117.12.116.18 -p 5432 -U web -d test</span><br></pre></td></tr></table></figure><h5 id="控制台命令"><a href="#控制台命令" class="headerlink" title="控制台命令"></a>控制台命令</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\h：查看SQL命令的解释，比如\h select。</span><br><span class="line">\?：查看psql命令列表。</span><br><span class="line">\l：列出所有数据库。</span><br><span class="line">\c [database_name]：连接其他数据库。</span><br><span class="line">\d：列出当前数据库的所有表格。</span><br><span class="line">\d [table_name]：列出某一张表格的结构(包含索引)。</span><br><span class="line">\du：列出所有用户。</span><br><span class="line">\q：退出数据库。</span><br><span class="line">\conninfo：列出当前数据库和连接的信息。</span><br></pre></td></tr></table></figure><h5 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建数据库</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">name</span>;</span><br><span class="line"># 创建新表 </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">users</span> (<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>), signup_date <span class="built_in">DATE</span>);</span><br><span class="line"># 插入数据 </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">users</span>(<span class="keyword">name</span>, signup_date) <span class="keyword">VALUES</span>(<span class="string">'小猿大圣'</span>, <span class="string">'2017-01-15'</span>);</span><br><span class="line"># 选择记录 </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span>;</span><br><span class="line"># 更新数据 </span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">users</span> <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'小猿大圣'</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'小猿大圣'</span>;</span><br><span class="line"># 删除记录 </span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'小猿大圣'</span> ;</span><br><span class="line"># 添加栏位 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">users</span> <span class="keyword">ADD</span> email <span class="built_in">VARCHAR</span>(<span class="number">40</span>);</span><br><span class="line"># 更新结构 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">users</span> <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> signup_date <span class="keyword">SET</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line"># 更名栏位 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">users</span> <span class="keyword">RENAME</span> <span class="keyword">COLUMN</span> signup_date <span class="keyword">TO</span> signup;</span><br><span class="line"># 删除栏位 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">users</span> <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> email;</span><br><span class="line"># 删除表格 </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> backups;</span><br><span class="line"># 删除数据，速度快，会保留表结构</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> tablename;</span><br><span class="line"># 删除数据以及外键</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> tablename <span class="keyword">CASCADE</span>;</span><br><span class="line"># 求平均值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(helper) <span class="keyword">FROM</span> games;</span><br><span class="line"># 求最大值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(helper_num) <span class="keyword">FROM</span> games;</span><br><span class="line"># 求数量不重复</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> open_id) <span class="keyword">FROM</span> games;</span><br><span class="line"># 求和</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(amount) <span class="keyword">FROM</span> games; </span><br><span class="line"># 模糊查询</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'小猿大%'</span>;</span><br><span class="line"># 排序 ASC 升序 默认，DESC 降序</span><br><span class="line"><span class="keyword">SELECT</span> c1, c2 <span class="keyword">FROM</span> tbl_name <span class="keyword">ORDER</span> <span class="keyword">BY</span> c1 <span class="keyword">ASC</span>, c2 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查出表中有重复的 id 的记录，并计算相同 id 的数量</span><br><span class="line"><span class="keyword">SELECT</span> user_id,<span class="keyword">COUNT</span>(user_id) <span class="keyword">FROM</span> games <span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id <span class="keyword">HAVING</span> (<span class="keyword">COUNT</span>(user_id)&gt;<span class="number">1</span>)</span><br><span class="line"># 合集 合并 Helpers 表和 Games 表 的 user_id 字段 (ALL 是不去重)</span><br><span class="line"><span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> games <span class="keyword">UNION</span> ALL <span class="keyword">SELECT</span> assistance_user_id <span class="keyword">FROM</span> helpers;</span><br><span class="line"># 统计上表中的字段重复的次数</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>,<span class="keyword">COUNT</span>(<span class="keyword">count</span>) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> user_id,<span class="keyword">COUNT</span>(user_id) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> user_id <span class="keyword">FROM</span> games <span class="keyword">UNION</span> ALL <span class="keyword">SELECT</span> assistance_user_id <span class="keyword">FROM</span> helpers ) <span class="keyword">AS</span> foo;</span><br></pre></td></tr></table></figure><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="如何从-csv-文件更新数据到数据库？-点击我"><a href="#如何从-csv-文件更新数据到数据库？-点击我" class="headerlink" title="如何从 csv 文件更新数据到数据库？ 点击我"></a>如何从 <code>csv</code> 文件更新数据到数据库？ <a href="https://stackoverflow.com/questions/8910494/how-to-update-selected-rows-with-values-from-a-csv-file-in-postgres" target="_blank" rel="noopener">点击我</a></h4><h4 id="如果将查询结果导出到-csv-文件"><a href="#如果将查询结果导出到-csv-文件" class="headerlink" title="如果将查询结果导出到 csv 文件"></a>如果将查询结果导出到 <code>csv</code> 文件</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">\copy (<span class="keyword">select</span> <span class="keyword">distinct</span> helpers.open_id <span class="keyword">from</span> helpers <span class="keyword">left</span> <span class="keyword">join</span> <span class="keyword">users</span> <span class="keyword">on</span> helpers.open_id = users.open_id  <span class="keyword">where</span> users.open_id <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">union</span> <span class="keyword">select</span> open_id <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> user_id <span class="keyword">from</span> exchanges)) <span class="keyword">TO</span> <span class="string">'/tmp/rm_openid.csv'</span> (<span class="keyword">format</span> CSV);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">\copy (<span class="keyword">select</span> union_id  <span class="keyword">From</span> <span class="keyword">users</span> <span class="keyword">where</span> open_id <span class="keyword">is</span> <span class="literal">null</span>) <span class="keyword">TO</span> <span class="string">'/tmp/filename.csv'</span> (<span class="keyword">format</span> CSV);</span><br></pre></td></tr></table></figure><h4 id="数据库备份"><a href="#数据库备份" class="headerlink" title="数据库备份"></a>数据库备份</h4><p><strong>备份数据库数据</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_dump <span class="comment">--host 地址 --port 端口 --username 数据库的用户名 &gt; 导出的文件 数据库名字</span></span><br><span class="line"></span><br><span class="line">例子:</span><br><span class="line"></span><br><span class="line">pg_dump <span class="comment">--host xxxxx.com --port 3434 --username admin  &gt; file.sql dataname</span></span><br></pre></td></tr></table></figure><p><strong>数据导入数据库</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">psql -d 数据库名字 -f 文件名 用户名</span><br><span class="line"></span><br><span class="line">例子:</span><br><span class="line"></span><br><span class="line">psql -d dataname -f file.sql admin</span><br></pre></td></tr></table></figure><h4 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h4><p>将来补充</p><h4 id="用户、角色、权限管理"><a href="#用户、角色、权限管理" class="headerlink" title="用户、角色、权限管理"></a>用户、角色、权限管理</h4><p><a href="http://www.jianshu.com/p/b09d0b29faa9" target="_blank" rel="noopener">PostgreSQL学习笔记(九) 用户、角色、权限管理</a></p><p>创建用户并赋予权限</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">CREATE USER www WITH PASSWORD 'u867#eDgg6#2@elo098OIUh';</span><br><span class="line"></span><br><span class="line">CREATE DATABASE my_app_prod OWNER www;</span><br><span class="line"></span><br><span class="line">alter role www login createdb;</span><br></pre></td></tr></table></figure><h4 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h4><p>1、macOS postgres 角色不存在</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">** (Postgrex.Error) FATAL 28000 (invalid_authorization_specification): role "postgres" does not exist</span><br></pre></td></tr></table></figure><p><strong>解决</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">psql -d postgres</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> postgres <span class="keyword">WITH</span> OWNER postgres;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> postgres SUPERUSER;</span><br></pre></td></tr></table></figure><p>2、升级版本后，数据库无法启动</p><p>报错如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">could not connect to server: No such file or directory</span><br><span class="line">Is the server running locally and accepting</span><br><span class="line">connections on Unix domain socket &quot;/tmp/.s.PGSQL.5432&quot;?</span><br><span class="line"></span><br><span class="line">FATAL:  database files are incompatible with server</span><br></pre></td></tr></table></figure><p>解决：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew postgresql-upgrade-database</span><br></pre></td></tr></table></figure><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://www.infoq.com/cn/news/2013/12/mysql-vs-postgresql" target="_blank" rel="noopener">MySQL与PostgreSQL：该选择哪个开源数据库？哪一个更好？</a></p><p><a href="http://www.infoq.com/cn/news/2015/03/why-postgresql-not-mysql" target="_blank" rel="noopener">为什么选择PostgreSQL而不是MySQL</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文记录了 &lt;code&gt;PostgreSQL&lt;/code&gt; 基本操作，入门的 &lt;code&gt;SQL&lt;/code&gt; 语句以及高阶的联表查询等内容。本文自用，时常更新。&lt;code&gt;PostgreSQL&lt;/code&gt; 和 &lt;code&gt;MySQL&lt;/code
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>咖啡带来了久违的技术兴奋</title>
    <link href="https://hufangyun.com/2017/coffee-night/"/>
    <id>https://hufangyun.com/2017/coffee-night/</id>
    <published>2017-10-18T18:21:41.000Z</published>
    <updated>2017-11-12T10:25:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>咖啡带来了久违的技术兴奋。</p><p>今天试着喝了点咖啡。有点小兴奋，哎，久违的感觉。工作之后，就很少有熬夜熬到兴奋的情况了。每次都是感觉很累，想睡。</p><p>大学的时候，经常熬夜各种折腾，技术给我的莫名兴奋，会让我像打了鸡血一样，熬战到天明。这种感觉很久没有来临过了。</p><p>声音，只剩下了耳机里音乐的流转和键盘敲击的清脆。<br>光亮，只剩下了漆黑房间内的电脑屏幕。</p><p>我喜欢这样的氛围，喜欢在光与暗的结合里，技术带给我的小确幸。</p><p>2017-11-12 更新</p><p>凛冬已至，夜幕降临的越来越早了。我喜欢这样的季节，这样的夜晚，宅在家里，关闭房间内所有的灯光，在键盘的背光下敲击、思考。</p><p>将来，想把家里装修成最舒服的地方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;咖啡带来了久违的技术兴奋。&lt;/p&gt;
&lt;p&gt;今天试着喝了点咖啡。有点小兴奋，哎，久违的感觉。工作之后，就很少有熬夜熬到兴奋的情况了。每次都是感觉很累，想睡。&lt;/p&gt;
&lt;p&gt;大学的时候，经常熬夜各种折腾，技术给我的莫名兴奋，会让我像打了鸡血一样，熬战到天明。这种感觉很久没有来临
      
    
    </summary>
    
      <category term="随笔" scheme="https://hufangyun.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>由 ECMA 规范解读 Javascript 可执行上下文概念</title>
    <link href="https://hufangyun.com/2017/ecma-execution-contexts/"/>
    <id>https://hufangyun.com/2017/ecma-execution-contexts/</id>
    <published>2017-10-04T17:37:01.000Z</published>
    <updated>2018-02-03T17:37:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>其实规范这东西不是给人看的，它更多的是给语言实现者提供参考。但是当碰到问题找不到答案时，规范往往能提供想要的答案 。偶尔读一下能够带来很大的启发和思考，如果只读一章 Javascript 规范，大神们觉得非第10章莫属。</p></blockquote><p>我们来试试看，这次选用的是 <code>ECMA2.2</code>的 5.1 版，整个规范才200页， 而第10章共10页，可以感受到 <code>Javascript</code> 的精简，目前的版本加了太多 ES6 的东西，让人望而生畏。</p><p>资料地址：<a href="http://www.ecma-international.org/ecma-262/5.1/Ecma-262.pdf" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/5.1/Ecma-262.pdf</a></p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>阅读 <code>ECMA262</code> 5.1 第10章 <code>Executable Code and Execution Contexts</code> (可执行代码与执行上下文)<br>你能针对这章内容提出问题吗？ 即知道答案找出问题。<br>你能使用图来更形象地表达文章内容吗？</p><h2 id="开始我们的探险之旅"><a href="#开始我们的探险之旅" class="headerlink" title="开始我们的探险之旅"></a>开始我们的探险之旅</h2><p>原汁原味 <a href="http://www.ecma-international.org/ecma-262/5.1" target="_blank" rel="noopener">ECMAScript 5.1 英文版</a><br>平易近人 <a href="https://www.w3.org/html/ig/zh/wiki/ES5/%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">ECMAScript 5.1 中文版</a></p><h2 id="可执行代码类型"><a href="#可执行代码类型" class="headerlink" title="可执行代码类型"></a>可执行代码类型</h2><blockquote><p>像 <code>v8</code> 等 <code>JavaScript</code> 引擎都是按照 <code>ecma-262</code> 的规范来实现的，<code>JavaScript</code> 引擎在解释 <code>JavaScript</code> 代码时，将可执行代码分为了三种。分别是：</p></blockquote><ul><li><p><strong>全局代码</strong><br>  代码加载时首先进入的环境。<br>  例如加载外部的 JavaScript 文件或者本地 <script></script> 标签内的代码。<br>  但不包括任何 function 体内的代码。</p></li><li><p><strong>函数代码</strong><br>  是指作为 function 被解析的源代码。<br>  不包括作为其嵌套函数的 function 被解析的源代码。<br>  因为 JavaScript 函数中还可以嵌套函数，因此这也是三种可执行代码中最复杂的一种。</p></li><li><p><strong><code>eval</code>代码</strong><br>  指的是传递给 eval 内置函数的代码。</p></li></ul><p>注：不了解 <code>eval（string）</code> 的小伙伴，请参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="noopener">eval() - JavaScript | MDN</a></p><blockquote><p>当 <code>JavaScript</code> 引擎开始执行（进入）一段可执行代码之后，会生成一个执行环境（Execution Context)，或执行上下文。引擎用执行环境来维护执行当前代码所需要的变量声明、this指向等。</p></blockquote><p><img src="/media/2624009007-59e545c159240_articlex.jpeg" alt="2624009007-59e545c159240_articlex"><span class="img-alt">2624009007-59e545c159240_articlex</span></p><h2 id="词法环境-Lexical-Environments"><a href="#词法环境-Lexical-Environments" class="headerlink" title="词法环境 (Lexical Environments)"></a>词法环境 (Lexical Environments)</h2><p><code>词法环境</code> 是执行环境的三个组成的状态之一。</p><p><code>官方解释：</code>词法环境是用来定义特定变量和函数标识符的。一个词法环境由一个<strong>环境记录项</strong>和可能为空的<strong>外部词法环境</strong>引用构成。</p><blockquote><p>通常词法环境会与 <code>ECMAScript</code> 代码诸如 <code>函数声明（FunctionDeclaration）</code>、<code>WithStatement</code> 或者 <code>TryStatement</code> 的 <code>Catch</code> 块这样的特定句法结构相联系，且类似代码每次执行都会<strong>有一个新的词法环境</strong>被创建出来。</p></blockquote><blockquote><p><strong>外部词法环境引用</strong> 用于表示词法环境的逻辑嵌套关系模型。（内部）词法环境的外部引用是逻辑上包含内部词法环境的词法环境。外部词法环境自然也可能有多个内部词法环境。</p></blockquote><blockquote><p>例如，如果一个 FunctionDeclaration 包含两个嵌套的 FunctionDeclaration，那么每个内嵌函数的词法环境都是外部函数本次执行所产生的词法环境。</p></blockquote><p><strong>环境记录项</strong> 又可以分为两种<strong>声明式环境记录项</strong>和<strong>对象式环境记录项</strong>。</p><p>声明式环境记录项 用于标识标识符和<code>函数声明</code>、<code>变量声明</code>、<code>catch 语句</code>等语法元素的绑定。对象式环境记录项 主要用于定义那些将标识符与具体对象的属性绑定的语法元素。</p><p>咬文嚼字，不好理解？</p><p><code>通俗点讲：</code> 词法环境就是 JavaScript 引擎在执行代码过程中用来标识函数声明、变量声明这一类的。我们每次声明一个函数，或者使用 <code>with</code> 、<code>catch</code>语句的时候，就会有新的词法环境被创建出来。全局词法环境的外部词法环境就是空的，因为他已经是最外层的词法环境了。</p><p>我们用个例子来说明词法环境：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> z = <span class="number">30</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">q</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y+z+q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo(<span class="number">20</span>);</span><br><span class="line">bar(<span class="number">40</span>);</span><br></pre></td></tr></table></figure><p><img src="/media/2735347362-59e54b066ff9b_articlex.jpeg" alt="2735347362-59e54b066ff9b_articlex"><span class="img-alt">2735347362-59e54b066ff9b_articlex</span></p><h3 id="词法环境的运算"><a href="#词法环境的运算" class="headerlink" title="词法环境的运算"></a>词法环境的运算</h3><p>给出一个标识符字符串，首先在当前的词法环境内寻找，如果存在，返回引用的标识符字符串，如果不存在，再在当前词法环境的外部词法环境寻找。</p><p>咦，怎么感觉和作用域链的概念很相似？他们有什么关系吗？</p><ul><li><strong>执行环境</strong> 当执行流进入一个函数时，函数的环境会被推入一个环境栈中。当函数执行之后，环境栈将其弹出，把控制权返回给之前的执行环境。</li><li><strong>作用域链</strong> 当代码在一个环境中执行时，会创建变量对象的一个作用域链。其用途是保证对执行环境有权访问的所有变量和函数的<strong>有序访问</strong>。一个包含环境的变量对象到另一个包含环境的变量对象，最后到全局执行环境的变量对象。</li></ul><p>函数只要被创建，就会有自己的“地盘”，有自己的作用域。但是只有函数被执行的时候，才会有自己的执行环境。函数执行完毕的时候，执行环境就会退出。而且一个作用域下可能存在多个执行环境，比如闭包。</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>1、词法环境分为了两部分：环境记录项和外部词法环境。<br>2、环境记录项根据绑定的 ECMA 脚本元素的不同也分为了两部分。<br>3、函数声明或者使用 <code>with</code> 、<code>catch</code>语句时，就会有新的词法环境被创建出来。</p><h2 id="执行环境（Execution-Contexts）"><a href="#执行环境（Execution-Contexts）" class="headerlink" title="执行环境（Execution Contexts）"></a>执行环境（Execution Contexts）</h2><p>如果我们的 <code>JavaScript</code> 程序有各种函数，函数之间还有嵌套的情况，那 <code>JavaScript</code> 引擎怎么解释各种声明和执行上下文哪？</p><p>当控制器转入 <code>ECMA</code> 脚本的可执行代码时，上文已经说了有三种可执行代码，不管进入哪一种控制器都会进入一个执行环境。多个执行环境在逻辑上形成一个<strong>栈结构</strong>。栈结构最顶层的执行环境称为当前运行的执行环境，最底层是全局执行环境。</p><p>用一张图解释</p><p><img src="/media/1243889088-59c8b7e123cd6_articlex.png" alt="1243889088-59c8b7e123cd6_articlex"><span class="img-alt">1243889088-59c8b7e123cd6_articlex</span></p><p>因为 JS 引擎被实现为单线程，也就是同一时间只能发生一件事情，其他的行为就会依次排队。</p><p>你可以有任意多个函数执行环境，每次调用函数创建一个新的执行环境，会创建一个私有作用域，函数内部声明的任何变量都不能在当前函数作用域外部直接访问。函数能访问当前执行环境外面的变量声明，但在外部执行环境不能访问内部的变量/函数声明。</p><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p>关于执行栈（调用栈）</p><pre><code>单线程。同步执行。一个全局上下文。无限制函数上下文。每次函数被调用创建新的执行上下文，包括调用自己。return 或者抛出异常退出一个执行环境。</code></pre><p>我们用一个具体的函数理解：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(i) &#123;</span><br><span class="line">  if (i &lt; 0) return;</span><br><span class="line">  console.log(&apos;begin:&apos; + i);</span><br><span class="line">  foo(i - 1);</span><br><span class="line">  console.log(&apos;end:&apos; + i);</span><br><span class="line">&#125;</span><br><span class="line">foo(2);</span><br><span class="line"></span><br><span class="line">// 输出:</span><br><span class="line"></span><br><span class="line">// begin:2</span><br><span class="line">// begin:1</span><br><span class="line">// begin:0</span><br><span class="line">// end:0</span><br><span class="line">// end:1</span><br><span class="line">// end:2</span><br></pre></td></tr></table></figure><p><img src="/media/1606300353-59b5b7f1caff1_articlex%20-1-.png" alt="1606300353-59b5b7f1caff1_articlex -1-"><span class="img-alt">1606300353-59b5b7f1caff1_articlex -1-</span></p><p>代码的执行流程进入内部函数，创建一个新的执行上下文并把它压入执行栈的顶部。<strong>浏览器总会执行位于栈顶的执行上下文，一旦当前上下文函数执行结束，它将被从栈顶弹出，并将上下文控制权交给当前的栈。</strong> 这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。</p><blockquote><p>执行环境包含所有用于追踪与其相关的代码的执行进度的状态。精确地说，每个执行环境包含如下表列出的组件。</p></blockquote><p>执行环境的三个状态</p><table><thead><tr><th>组件</th><th>作用目的</th></tr></thead><tbody><tr><td>词法环境</td><td>指定一个词法环境对象，用于解析该执行环境内的代码创建的标识符引用。</td></tr><tr><td>变量环境</td><td>指定一个词法环境对象，其环境数据用于保存由该执行环境内的代码通过 变量表达式 和 函数表达式 创建的绑定。</td></tr><tr><td>this 绑定</td><td>指定该执行环境内的 <code>ECMA</code> 脚本代码中 <code>this</code> 关键字所关联的值。</td></tr></tbody></table><p>当创建一个执行环境时，其词法环境组件和变量环境组件最初是同一个值。在该执行环境相关联的代码的执行过程中，变量环境组件永远不变，而词法环境组件有可能改变。变量环境的不变和词法环境的可能改变都是指引用的改变。</p><p><img src="/media/2624009007-59e545c159240_articlex-1.jpeg" alt="2624009007-59e545c159240_articlex"><span class="img-alt">2624009007-59e545c159240_articlex</span></p><h2 id="建立执行环境"><a href="#建立执行环境" class="headerlink" title="建立执行环境"></a>建立执行环境</h2><blockquote><p>解释执行全局代码或使用 <code>eval</code> 函数输入的代码会创建并进入一个新的执行环境。每次调用 <code>ECMA</code> 脚本代码定义的函数也会建立并进入一个新的执行环境，即便函数是自身递归调用的。</p></blockquote><blockquote><p>每一次 <code>return</code> 都会退出一个执行环境。抛出异常也可退出一个或多个执行环境。</p></blockquote><blockquote><p><strong>当控制流进入一个执行环境时，会设置该执行环境的 <code>this</code> 绑定组件，定义变量环境和初始词法环境，并执行声明式绑定初始化过程。</strong>以上这些步骤的严格执行方式由进入的代码的类型决定。</p></blockquote><h3 id="进入全局代码"><a href="#进入全局代码" class="headerlink" title="进入全局代码"></a>进入全局代码</h3><p>执行以下步骤：</p><pre><code>1、将变量环境设置为 全局环境 。 2、将词法环境设置为 全局环境 。3、将 this 绑定设置为 全局对象 。4、使用全局代码执行声明式绑定初始化化步骤。</code></pre><h3 id="进入函数代码"><a href="#进入函数代码" class="headerlink" title="进入函数代码"></a>进入函数代码</h3><blockquote><p>当控制流根据一个函数对象 F、调用者提供的 <code>thisArg</code> 以及调用者提供的 <code>argumentList</code>，进入函数代码的执行环境时，执行以下步骤</p></blockquote><pre><code>如果函数代码是严格模式下的代码，设 this 绑定 为 thisArg。否则如果 thisArg 是 null 或 undefined，则设 this 绑定 为全局对象。否则如果 Type(thisArg) 的结果不为 Object，则设 this 绑定 为 ToObject(thisArg)。否则设 this 绑定 为 thisArg。以 F 的 [[Scope]] 内部属性为参数调用 NewDeclarativeEnvironment(新建声明式词法环境)，并令 localEnv 为调用的结果。设 词法环境组件 为 localEnv。设 变量环境组件 为 localEnv。令 code 为 F 的 [[Code]] 内部属性的值。使用函数代码 code 和 argumentList 执行声明式绑定初始化化步骤。</code></pre><p>我们用伪代码表示一下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(是 严格模式) &#123;</span><br><span class="line">    this = thisArg</span><br><span class="line">&#125; else if(thisArg === null || thisArg === undefined) &#123;</span><br><span class="line">    this = window</span><br><span class="line">&#125; else if(typeof thisArg != &apos;object&apos;) &#123;</span><br><span class="line">    this = Object(thisArg)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    this = thisArg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哎，这里的 <code>thisArg</code> 指的是什么？上文说了 <code>thisArg</code> 来自于函数的调用者。</p><p>这里代表函数的 <code>apply</code>，<code>call</code>，<code>bind</code> 等设置 <code>this</code> 绑定的参数：</p><p>通过 <code>call</code> 或者 <code>apply</code> 调用函数时，<code>thisArg</code> 的值比较明显，为传入的第一个参数。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function.prototype.apply (thisArg, argArray)</span><br><span class="line"></span><br><span class="line">Function.prototype.call (thisArg [ , arg1 [ , arg2, … ] ] )</span><br></pre></td></tr></table></figure><p>当然 <code>thisArg</code> 还有其他的可能，具体的可以参考这篇文章 <a href="http://www.cnblogs.com/Kingle/p/3281816.html" target="_blank" rel="noopener">Javascript this 解析</a></p><p>对上面的伪代码做一下解释：</p><p><strong>严格模式:</strong> 也就是说，在严格模式下，<code>this</code> 只能为 <code>thisArg</code>，而当 <code>thisArg</code> 为 <code>undefined</code> 时，<code>this</code> 就是 <code>undefined</code> ，而不是 <code>window</code>。</p><p><strong>非严格模式:</strong> 如果 <code>thisArg</code> 是 <code>null</code> (如 <code>fun.call(null)</code>) 或 <code>undefined</code> （直接调用函数），则 <code>this</code> 为全局对象，浏览器里就是 <code>window</code>。</p><p>否则，如果 传入了 <code>thisArg</code>, 但不是个对象，则把它转为对象，并赋给 <code>this</code>，比如，当 <code>fun.call(&#39;hhh&#39;)</code> 时，打印 fun 内的 <code>this</code> 为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String &#123;0: &quot;h&quot;, 1: &quot;h&quot;, 2: &quot;h&quot;, length: 3, [[PrimitiveValue]]: &quot;hhh&quot;&#125;</span><br></pre></td></tr></table></figure><p>否则 ，也就是仅剩的一种情况，显式的传入了一个对象作为 <code>thisArg</code> 参数的情况下，设 <code>this</code> 绑定为 <code>thisArg</code>。</p><h2 id="声明式绑定初始化"><a href="#声明式绑定初始化" class="headerlink" title="声明式绑定初始化"></a>声明式绑定初始化</h2><p>每个执行环境都有一个关联的 <code>变量环境</code>。当在一个执行环境下评估一段 <code>ECMA</code> 脚本时，变量和函数定义会以绑定的形式添加到这个 <code>变量环境</code> 的环境记录中。对于函数代码，参数也同样会以绑定的形式添加到这个 <code>变量环境</code> 的环境记录中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ECMAScript</code> 代码的执行由运行环境来完成。不同的运行环境可能采取不同的执行方式，但基本的流程是相同的。如浏览器在解析 <code>HTML</code> 页面中遇到 <code>&lt;script&gt;</code> 元素时，会下载对应的代码来运行，或直接执行内嵌的代码。代码的基本执行方式是从上到下，顺序执行。在调用函数之后，代码的执行会进入一个执行上下文之中。由于在一个函数的执行过程中会调用其他的函数，执行过程中的活动执行上下文会形成一个堆栈结构。在栈顶的是当前正在执行的代码。当函数返回时，会退出当前的执行上下文，而回到之前的执行上下文中。如果代码执行中出现异常，则可能从多个执行上下文中退出。</p><p>在代码执行过程中很重要的一步是标识符的解析。比如当执行过程中遇到语句 <code>alert(val)</code> 时，首先要做的是解析标识符 <code>val</code> 的值。<code>ECMAScript</code> 不同于 <code>Java</code> 和 <code>C/C++</code> 等语言，在进行标识符解析时需要利用词法环境并与函数调用方式相关。具体来说，标识符解析由当前代码所对应的执行上下文来完成。为了描述标识符的解析过程，<code>ECMAScript</code> 规范中使用了词法环境的概念来进行描述。一个词法环境描述了标识符与变量或函数之间的对应关系。一个词法环境由两个部分组成：一部分是记录标识符与变量之间的绑定关系的环境记录，另一部分是包围当前词法环境的外部词法环境。环境记录可以看成是一个标识符与变量或函数之间的映射表。不同词法环境之间可以互相嵌套，而内部词法环境会持有一个包围它的外部词法环境的引用。在进行标识符解析时，如果当前词法环境中找不到标识符所对应的变量或函数，则使用外部词法环境来尝试解析。递归查找下去，直到解析成功或外部词法环境为 <code>null</code>。</p><p>具体来说，根据标识符关联方式的不同，环境记录可以进一步分成两类。两种类型分别对应不同的 <code>ECMAScript</code> 中不同的语法结构。当使用这些语法结构时，会对环境记录中的内容产生影响，进而影响标识符的解析过程。第一类环境记录是声明式环境记录。顾名思义，声明式环境记录用来绑定 <code>ECMAScript</code> 代码中的变量声明。当使用 <code>var</code> 声明变量或使用类似 <code>function func(){}</code> 的形式声明函数时，对应的变量或函数会被绑定到相应的环境记录中。另一类环境记录是对象环境记录。对象环境记录并不绑定具体的变量或函数，而是绑定另外一个对象中的属性。对象环境变量主要用来描述 <code>ECMAScript</code> 中 <code>with</code> 操作符的行为。</p><p>每个执行上下文会对应两个不同的词法环境。一个是用来进行标识符解析的词法环境，可能随着代码的执行而发生变化；另外一个是包含执行上下文对应的作用域中的变量或函数声明的词法环境。</p><h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><p>读完这篇文章，问问自己，能够回答下面的问题吗？</p><p>1、ECMAScript 中可执行代码有几种？<br>2、什么情况下会创建一个执行环境？<br>3、什么情况下会退出一个执行环境？<br>4、作用域链和执行环境的关系？<br>5、执行环境的存在是为了解决什么？<br>6、词法环境和变量环境的异同？<br>7、this 的绑定的几种情况？</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.w3.org/html/ig/zh/wiki/ES5/%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83#.E6.A0.87.E8.AF.86.E7.AC.A6.E8.A7.A3.E6.9E.90" target="_blank" rel="noopener">ES5/可执行代码与执行环境</a><br><a href="http://www.cnblogs.com/TomXu/archive/2012/01/13/2308101.html" target="_blank" rel="noopener">深入理解JavaScript系列（11）：执行上下文（Execution Contexts）</a><br><a href="http://yanhaijing.com/javascript/2014/04/29/what-is-the-execution-context-in-javascript/" target="_blank" rel="noopener">了解JavaScript的执行上下文</a><br><a href="https://segmentfault.com/a/1190000009041008" target="_blank" rel="noopener">深入理解JavaScript执行上下文、函数堆栈、提升的概念</a><br><a href="https://guxinyan.github.io/2017/01/12/%E5%85%B3%E4%BA%8Ejs%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%82%A3%E4%BA%9B%E4%BA%8B/" target="_blank" rel="noopener">关于js作用域那些事</a><br><a href="http://blog.csdn.net/zmhawk/article/details/76013924" target="_blank" rel="noopener"> 从 ECMAScript 规范来看 JS 的 this 绑定规则</a><br><a href="https://www.ibm.com/developerworks/cn/web/1305_chengfu_ecmascript5/" target="_blank" rel="noopener">深入探讨 ECMAScript 规范</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="http://www.html5jscss.com/js-data-scope.html" target="_blank" rel="noopener">JavaScript欲速则不达—通过解析过程了解JavaScript</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;其实规范这东西不是给人看的，它更多的是给语言实现者提供参考。但是当碰到问题找不到答案时，规范往往能提供想要的答案 
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
