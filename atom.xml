<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>胡方运的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hufangyun.com/"/>
  <updated>2019-04-23T14:20:21.000Z</updated>
  <id>https://hufangyun.com/</id>
  
  <author>
    <name>小猿大圣</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写给自己的JavaScript系列之一步步写个 JavaScript 解释器</title>
    <link href="https://hufangyun.com/2019/js-interpreter/"/>
    <id>https://hufangyun.com/2019/js-interpreter/</id>
    <published>2019-03-11T14:20:21.000Z</published>
    <updated>2019-04-23T14:20:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了更好的理解 JavaScript 的各种语言特性，更好的掌握 JavaScript 的底层原理 😄。我想动手写一个 JavaScript 版的 JavaScript 解释器。简单来说，就是能够运行 JavaScript（以下简称 js ） 代码。我们平时写的 js 代码一般由浏览器或者 Nodejs 的解释器来解释并执行，本文的目标就是写一个能够解释 js 代码的解释器 🚀。</p><p>写一个解释器的工程，想一想就感觉好大。咱们可以拆解一下，一步步来。每实现一个小目标都会很有成就感，不至于望而却步 🐶。</p><h2 id="第一阶段的目标"><a href="#第一阶段的目标" class="headerlink" title="第一阶段的目标"></a>第一阶段的目标</h2><p>✅ 1、首先实现打印值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="string">'Hello World!'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>2、然后实现加减乘除四则运算</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x + y);</span><br></pre></td></tr></table></figure><p>3、然后我们实现函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>4、趁热打铁实现闭包。</p><blockquote><p>实现闭包其实我想写一个 js 解释器的初始动机，我本来在写一篇解释什么是 js 闭包的文章，但是我写着写着感觉有点无聊，没什么意思，就想实现个 js 解释器。 从另一个角度理解这个问题。</p></blockquote><p>6、实现 if 条件表达式</p><p>7、实现 for 循环</p><p>8、打包 js 可以在其他文件内使用</p><blockquote><p>将执行结果输出到外部</p></blockquote><p>上面是我的玩具计划。</p><p>😌 ———————— 这是一条分割线 ———————- 😌</p><p>下面是我的开发过程。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>我找到的一些用 js 实现 js 解释器的文章：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/34191831" target="_blank" rel="noopener">微信小程序也要强行热更代码，鹅厂不服你来肛我呀</a></li><li><a href="https://juejin.im/post/5aa25be1518825557b4c5720#heading-11" target="_blank" rel="noopener">从零开始写一个Javascript解析器</a></li><li><a href="https://segmentfault.com/a/1190000017241258" target="_blank" rel="noopener">前端与编译原理——用JS写一个JavaScript解释器</a></li></ul><p>和上面文章相关的 Github 上的 JavaScript 解释器源码</p><blockquote><p>前三个是 TypeScript 项目，最后一个是 JavaScript 项目</p></blockquote><ul><li><a href="https://github.com/bramblex/jsjs" target="_blank" rel="noopener">jsjs</a></li><li><a href="https://github.com/jkeylu/evil-eval" target="_blank" rel="noopener">evil-eval</a></li><li><a href="https://github.com/axetroy/vm.js" target="_blank" rel="noopener">vm.js</a></li><li><a href="https://github.com/jrainlau/canjs" target="_blank" rel="noopener">canjs</a></li></ul><h2 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h2><p>JavaScript 代码转化成抽象语法树（AST）这一步，直接用现成的库实现。这里我们使用 <a href="https://github.com/acornjs/acorn" target="_blank" rel="noopener"><code>acorn</code></a> 库。这是一个 js 的解析器，可以将 js 代码解析成 AST，<code>Babel</code> 最开始也使用了 <code>acorn</code>。</p><p>如果你想了解整个编译器的开发（包括 AST 的生成），可以看这个项目<a href="https://github.com/jamiebuilds/the-super-tiny-compiler" target="_blank" rel="noopener">微型编译器</a></p><h3 id="抽象语法树（AST）"><a href="#抽象语法树（AST）" class="headerlink" title="抽象语法树（AST）"></a>抽象语法树（AST）</h3><p>大体解释一下。🐵</p><blockquote><p>在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现；而类似于 if-condition-then 这样的条件跳转语句，可以使用带有两个分支的节点来表示。  – 维基百科</p></blockquote><p>AST 的作用：</p><ul><li>代码风格检测(eslint等)</li><li>代码的格式化，自动补全</li><li>代码高亮</li><li>代码错误检查</li><li>代码的混淆压缩</li><li>转换代码的工具。如 webpack，rollup。各种代码规范之间的转换，TypeScript JSX 等转换为原生 js</li></ul><p>实际项目中对 AST 的应用：</p><p>我在网上找到的三个案例：🌏</p><p><a href="https://segmentfault.com/a/1190000013423155" target="_blank" rel="noopener">分析统计微信小程序代码使用的 api</a></p><p><a href="https://qianduan.group/posts/5a0fe3cc44aec04413ec3d7d" target="_blank" rel="noopener">支付宝和微信小程序的代码转换</a></p><p><a href="https://tech.meituan.com/2014/10/08/the-practice-of-abstract-syntax-trees-in-javascript.html" target="_blank" rel="noopener">美团的模块依赖关系检测工具</a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>1、使用 acorn 将 js 转换成 ast 抽象语法树</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Parser &#125; = <span class="built_in">require</span>(<span class="string">'acorn'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runjs</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(code = '') &#123;</span><br><span class="line">    <span class="keyword">this</span>.ast = Parser.parse(code);</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.ast);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Runjs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Runjs(<span class="string">`</span></span><br><span class="line"><span class="string">  let x = 'Hello World!';</span></span><br><span class="line"><span class="string">  console.log(x);</span></span><br><span class="line"><span class="string">`</span>).run();</span><br></pre></td></tr></table></figure><p>我们可以使用这个工具看一下，解析出来的抽象语法树。😉</p><p><a href="http://esprima.org/demo/parse.html" target="_blank" rel="noopener">Esprima 在线工具</a></p><p><a href="https://astexplorer.net/" target="_blank" rel="noopener">ast</a></p><p>2、解析出来的 AST 每个节点都有个 type 属性，要做一个节点遍历器，处理每一个节点。</p><p>有哪些节点那？可以从这里<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/Parser_API" target="_blank" rel="noopener">查看</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">'Hello World!'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure><p>⬇️ 上面的代码生成的 AST 如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"Program"</span>,</span><br><span class="line">  <span class="attr">"body"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"VariableDeclaration"</span>,</span><br><span class="line">      <span class="attr">"declarations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"VariableDeclarator"</span>,</span><br><span class="line">          <span class="attr">"id"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"x"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"init"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Literal"</span>,</span><br><span class="line">            <span class="attr">"value"</span>: <span class="string">"Hello World!"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"kind"</span>: <span class="string">"const"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"ExpressionStatement"</span>,</span><br><span class="line">      <span class="attr">"expression"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"CallExpression"</span>,</span><br><span class="line">        <span class="attr">"callee"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"MemberExpression"</span>,</span><br><span class="line">          <span class="attr">"computed"</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">"object"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"console"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"property"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"log"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"arguments"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"Identifier"</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"x"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何实现节点遍历器？</p><p>先定义一个节点控制器 nodeHandler，分别处理每一个节点</p><p>下面是上面用到的节点类型：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nodeHandler = &#123;</span><br><span class="line">  Program(nodeIterator) &#123;</span><br><span class="line">    <span class="comment">/*处理 Program 类型的代码 */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  VariableDeclaration(nodeIterator) &#123;</span><br><span class="line">    <span class="comment">/*处理 VariableDeclaration 类型的代码 */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  Identifier(nodeIterator) &#123;&#125;,</span><br><span class="line">  Literal(nodeIterator) &#123;&#125;,</span><br><span class="line">  ExpressionStatement(nodeIterator) &#123;&#125;,</span><br><span class="line">  CallExpression(nodeIterator) &#123;&#125;,</span><br><span class="line">  MemberExpression(nodeIterator) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实现一个节点遍历器 🆗</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeIterator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(node) &#123;</span><br><span class="line">    <span class="keyword">this</span>.node = node;</span><br><span class="line">    <span class="keyword">this</span>.nodeHandler = nodeHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  traverse(node) &#123;</span><br><span class="line">    <span class="keyword">const</span> nodeIterator = <span class="keyword">new</span> NodeIterator(node);</span><br><span class="line">    <span class="keyword">const</span> parse = <span class="keyword">this</span>.nodeHandler[node.type];</span><br><span class="line">    <span class="keyword">if</span> (!parse) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`canjs: Unknown node type "<span class="subst">$&#123;node.type&#125;</span>".`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parse(nodeIterator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（未完待续~~~）🎈</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了更好的理解 JavaScript 的各种语言特性，更好的掌握 JavaScript 的底层原理 😄。我想动手写一个 JavaScript 版的 JavaScript 解释器。简单来说，就是能够运行 JavaScript（以下简称 js ） 代码。我们平时写的 js 代
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>写给自己的JavaScript系列之序</title>
    <link href="https://hufangyun.com/2019/js-0/"/>
    <id>https://hufangyun.com/2019/js-0/</id>
    <published>2019-02-18T05:08:16.000Z</published>
    <updated>2019-02-18T05:08:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我一直感觉自己的前端知识不够系统不够扎实，不像团队中的大牛基础扎实，可以举一反三，把各种原理讲的很通透，让人醍醐灌顶。一想到面试，就有点忐忑不安，没有底气。所以我想总结一系列的文章深入的学习 JavaScript 和一些前端知识，也更好的和大家交流探讨。</p></blockquote><h2 id="想涉及的内容"><a href="#想涉及的内容" class="headerlink" title="想涉及的内容"></a>想涉及的内容</h2><ul><li>写一个 JavaScript 的解释器，更好的理解这么语言</li><li>JavaScript 的一些概念和原理，比如闭包、原型链、作用域</li></ul><h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><p>写给自己的 JavaScript 系列之</p><p>闭包</p><p>this</p><p>站在巨人的肩膀上写个 JavaScript 的解释器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我一直感觉自己的前端知识不够系统不够扎实，不像团队中的大牛基础扎实，可以举一反三，把各种原理讲的很通透，让人醍醐灌顶。一想到面试，就有点忐忑不安，没有底气。所以我想总结一系列的文章深入的学习 JavaScript 和一些前端知识，也更好的和大家
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>视频格式转换笔记</title>
    <link href="https://hufangyun.com/2019/video-format-conversion-mp4/"/>
    <id>https://hufangyun.com/2019/video-format-conversion-mp4/</id>
    <published>2019-01-23T09:00:11.000Z</published>
    <updated>2019-01-23T09:00:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>macOS 命令行安装 <code>ffmpeg</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure><p>flv 转换成 MP4</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i file.flv file.mp4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;macOS 命令行安装 &lt;code&gt;ffmpeg&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;brew install ffmpe
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>代码整洁之道</title>
    <link href="https://hufangyun.com/2018/code-clean/"/>
    <id>https://hufangyun.com/2018/code-clean/</id>
    <published>2018-12-01T16:05:52.000Z</published>
    <updated>2018-12-14T16:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习和实践过程中，如果遇到其他的内容，我会逐渐完善这篇文章。以致于写出更好的代码。</p></blockquote><blockquote><p>以下内容选自 《代码整洁之道》 和 《重构》</p></blockquote><p>沃德原则：“如果每个例程都让你感到深合己意，那就是整洁代码。</p><p>代码应当讲述事实，不引人猜测。</p><p>软件项目的主要成本在于长期维护。所以，代码应当清晰地表达其作者的意图。作者把代码写得越清晰，其他人花在理解代码上的时间也就越少，从而减少缺陷，缩减维护成本。</p><p>写整洁代码，需要遵循大量的小技巧，贯彻刻苦习得的“整洁感”。</p><h2 id="通用规则"><a href="#通用规则" class="headerlink" title="通用规则"></a>通用规则</h2><ul><li>别重复自己的代码。</li></ul><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul><li><p>有意义的命名。</p><pre><code>让读代码的人，一下看到变量名、文件名、函数名，就知道这是做什么的。比如写了一个函数，里面的每一个命名，都可以让大家明白这个语句是做什么的。</code></pre></li><li><p>提防使用不同之处较小的名称。</p><pre><code>补全的时候不方便。也难以区分。</code></pre></li></ul><ul><li><p>类名和对象名应该是名词或名词短语，不应该使用动词。</p></li><li><p>方法名应该是动词或者动词短语。</p></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p>函数要保持短小，20行封顶最佳。</p></li><li><p>函数应该只做一件事。</p><pre><code>要判断函数是否不止做了一件事，办法就是看是否能再拆出一个函数。函数承诺只做一件事，但还是会做其他被藏起来的事。有时，它会对自己类中的变量做出未能预期的改动。有时，它会把变量搞成向函数传递的参数或是系统全局变量。无论哪种情况，都是具有破坏性的，会导致古怪的时序性耦合及顺序依赖。函数要么做什么事，要么回答什么事，但二者不可得兼。函数应该修改某对象的状态，或是返回该对象的有关信息。两样都干常会导致混乱。</code></pre></li><li><p>无副作用。</p></li><li><p>自顶向下读代码：向下规则。</p><pre><code>我们想要让每个函数后面都跟着位于下一抽象层级的函数，这样在查看函数列表时，就能偱抽象层级向下阅读了。</code></pre></li><li><p>函数越短小、功能越集中，就越便于取个好名字。</p></li><li><p>参数应该尽量少，最理想的参数数量是零（零参数函数）。</p><pre><code>1、参数需要理解2、从测试的角度看，参数叫人为难。要编写能确保参数的各种组合运行正常的测试用例，是多么困难的事。</code></pre></li><li><p>给函数取个好名字，能较好地解释函数的意图，以及参数的顺序和意图。</p><pre><code>对于一元函数，函数和参数应当形成一种非常良好的动词/名词对形式。例如，write(name) 就相当令人认同。不管这个 name 是什么，都要被 write。</code></pre></li></ul><blockquote><p>写代码和写别的东西很像。在写论文或文章时，你先想什么就写什么，然后再打磨它。初稿也许粗陋无序，你就斟酌推敲，直至达到你心目中的样子。我写函数时，一开始都冗长而复杂。有太多缩进和嵌套循环。有过长的参数列表。名称是随意取的，也会有重复的代码。不过我会配上一套单元测试，覆盖每行丑陋的代码。然后我打磨这些代码，分解函数、修改名称、消除重复。我缩短和重新安置方法。有时我还拆散类。同时保持测试通过。最后，遵循本章列出的规则，我组装好这些函数。我并不从一开始就按照规则写函数。我想没人做得到。</p></blockquote><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>如果你发现自己需要写注释，再想想看是否有办法翻盘，用代码来表达。每次用代码表达，你都该夸奖一下自己。每次写注释，你都该做个鬼脸，感受自己在表达能力上的失败。</p><h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><p>代码格式关乎沟通，而沟通是专业开发者的头等大事。 </p><p>这说明，应该尽力保持代码行短小。死守80个字符的上限有点僵化，而且我也并不反对代码行长度达到100个字符或120个字符。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><p>类应该短小。</p></li><li><p>类的名称应当描述其权责。</p><pre><code>实际上，命名正是帮助判断类的长度的第一个手段。如果无法为某个类命以精确的名称，这个类大概就太长了。类名越含混，该类越有可能拥有过多权责。</code></pre></li><li><p>类只应有一个权责——只有一条修改的理由。</p><pre><code>单一权责原则（SRP）[2]认为，类或模块应有且只有一条加以修改的理由。该原则既给出了权责的定义，又是关于类的长度的指导方针。系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为。</code></pre></li></ul><p>如开放-闭合原则（OCP）：类应当对扩展开放，对修改封闭。</p><p>只要遵循以下规则，设计就能变得“简单”：</p><ul><li>运行所有测试；</li><li>不可重复；</li><li>表达了程序员的意图；</li><li>尽可能减少类和方法的数量；</li></ul><p>以上规则按其重要程度排列。</p><p>只要系统可测试，就会导向保持类短小且目的单一的设计方案。遵循SRP的类，测试起来较为简单。测试编写得越多，就越能持续走向编写较易测试的代码。所以，确保系统完全可测试能帮助我们创建更好的设计。</p><p>有了测试，就能保持代码和类的整洁，方法就是递增式地重构代码。添加了几行代码后，就要暂停，琢磨一下变化了的设计。设计退步了吗？如果是，就要清理它，并且运行测试，保证没有破坏任何东西。测试消除了对清理代码就会破坏代码的恐惧。</p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>本质上说，重构就是「在代码写好之后改进它的设计」。</p><h3 id="重构的第一步"><a href="#重构的第一步" class="headerlink" title="重构的第一步"></a>重构的第一步</h3><p>每当要进行重构的时候，第一个步骤永远相同：我得为即将修改的代码建立一组可靠的测试环境。这些测试是必要的，因为尽管遵循重构准则可以使我避免绝大多数的 bug 引入机会，但我毕竞是人，毕竟有可能犯错。所以我需要可靠的测试。</p><p>重构技术系以微小的步伐修改程序。如果你犯下错误，很容易便可发现它。</p><h3 id="重构的节奏"><a href="#重构的节奏" class="headerlink" title="重构的节奏"></a>重构的节奏</h3><p>测试、小修改、测试、小修改、测试、小修改……。正是这种节奏让重构得以快速而安全地前进。</p><h3 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h3><p>三次法则<br>Don Roberts给了我一条准则：第一次做某件事时只管去做；第二次做类似的事会产生反感，但无论如何还是做了；第三次再做类似的事，你就应该重构。</p><p>Tip: 事不过三，三则重构（Three strikes and you refactor）</p><p>添加功能时一并重构</p><p>修补错误吋一并重构</p><p>复审代码吋一并重构</p><p>我们都曾经说过有朝一日再回头清理。当然，在那些日子里，我们都没听过勒布朗（LeBlanc）法则：稍后等于永不（Later equals never）。</p><p>所以，多少尊重一下你的手艺吧。花一点点时间在每个函数和类上。选用较好的名称，将大函数切分为小函数，时时照拂自己创建的东西。用心是最珍贵的资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;学习和实践过程中，如果遇到其他的内容，我会逐渐完善这篇文章。以致于写出更好的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以下内容选自 《代码整洁之道》 和 《重构》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;沃德原
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>写给自己的CSS系列（零）前言</title>
    <link href="https://hufangyun.com/2018/my-css-0/"/>
    <id>https://hufangyun.com/2018/my-css-0/</id>
    <published>2018-11-21T11:51:51.000Z</published>
    <updated>2018-11-21T11:51:51.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在读大神张鑫旭的《CSS世界》，收获颇多 💎 ，为了巩固学习的内容，我把学习到的知识整理成这个『写给自己的 CSS 系列』😄 。</p></blockquote><p>这个系列包含三部分内容：</p><p>1.《CSS世界》里部分内容的摘录。 🎨</p><p>2.阅读 《CSS世界》过程中，我的一些思考和相关知识的扩展。⚓ </p><p>3.之后我从其他地方学习到的相关知识，也会补充到这个系列里。 🍎</p><p>感觉之前对 CSS 理解的不够深入，遇到问题的时候总是一知半解，样式出了问题，总是用属性拼凑，云里雾中。希望之后在遇到 CSS 的问题，能够多总结，多思考。共勉之。💪</p><p>如果，文中有不对的地方，欢迎讨论，共同进步。👌</p><p>最后，推荐大家阅读 《CSS世界》。😄</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在读大神张鑫旭的《CSS世界》，收获颇多 💎 ，为了巩固学习的内容，我把学习到的知识整理成这个『写给自己的 CSS 系列』😄 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个系列包含三部分内容：&lt;/p&gt;
&lt;p&gt;1.《CSS世界》里部分内容
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>写给自己的CSS系列（一）基础概念</title>
    <link href="https://hufangyun.com/2018/my-css-1-base/"/>
    <id>https://hufangyun.com/2018/my-css-1-base/</id>
    <published>2018-11-21T00:54:47.000Z</published>
    <updated>2018-11-21T00:54:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h2><h3 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h3><blockquote><p>相对长度单位又分为相对字体长度单位和相对视区长度单位。</p></blockquote><ul><li><p>相对字体长度单位，如 <code>em</code> 和 <code>ex</code>，还有 <code>CSS3</code> 新世界的 <code>rem</code> 和 <code>ch</code>(字符 0 的宽度)。</p></li><li><p>相对视区长度单位，如 <code>vh</code>、<code>vw</code>、<code>vmin</code> 和 <code>vmax</code>。 </p></li></ul><h3 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h3><p>最常见的就是 <code>px</code>，还有 <code>pt</code>、<code>cm</code>、<code>mm</code>、<code>pc</code> 等了解一下就可以。（在我<br>看来，它们实用性近乎零，至少我这么多年一次都没用过。– 张鑫旭 《CSS世界》）</p><h2 id="选择器和关系选择器"><a href="#选择器和关系选择器" class="headerlink" title="选择器和关系选择器"></a>选择器和关系选择器</h2><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><blockquote><p>选择器是用来瞄准目标元素的东西</p></blockquote><ul><li><p>类选择器: 指以 <code>.</code> 这个点号开头的选择器。</p></li><li><p><code>ID</code> 选择器: <code>#</code> 打头，权重相当高。<code>ID</code> 一般指向唯一元素。但是，在 <code>CSS</code> 中，<code>ID</code><br>样式出现在多个不同的元素上并不会只渲染第一个，而是雨露均沾。但显然不推荐<br>这么做。</p></li><li><p>属性选择器: 指含有 <code>[]</code> 的选择器，形如 <code>[title]{}</code>、<code>[title= &quot;css-world&quot;]{}</code>、<br><code>[title~=&quot;css-world&quot;]{}</code> 、 <code>[title^= &quot;css-world&quot;]{}</code> 和 <code>[title$=&quot;css-world&quot;]{}</code> 等。</p></li><li><p>伪类选择器: 一般指前面有个英文冒号 <code>:</code> 的选择器，如 <code>:first-child</code> 或<code>:last-child</code> 等。</p></li><li><p>伪元素选择器: 就是有连续两个冒号的选择器，如 <code>::first-line</code>、<code>::first-letter</code>、<code>::before</code> 和 <code>::after</code>。</p></li></ul><h3 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h3><blockquote><p>关系选择器是指根据与其他元素的关系选择元素的选择器，常见的符号有空格、<code>&gt;</code>、<code>~</code>，还有 <code>+</code> 等，这些都是非常常用的选择器。</p></blockquote><ul><li><p>后代选择器: 选择所有合乎规则的后代元素。空格连接。</p></li><li><p>相邻后代选择器: 仅仅选择合乎规则的儿子元素，孙子、重孙元素忽略，因此又称“子<br>选择器”。<code>&gt;</code> 连接。适用于 <code>IE7</code> 以上版本。</p></li><li><p>兄弟选择器: 选择当前元素后面的所有合乎规则的兄弟元素。<code>~</code> 连接。适用于 <code>IE7</code> 以上版本。</p></li><li><p>相邻兄弟选择器: 仅仅选择当前元素相邻的那个合乎规则的兄弟元素。<code>+</code> 连接。适用于 <code>IE7</code> 以上版本。</p></li></ul><h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p>『块级元素』对应的英文是 <code>block-level element</code>，常见的块级元素有 <code>&lt;div&gt;</code>、<code>&lt;li&gt;</code> 和 <code>&lt;table&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;h1&gt;</code> ~ <code>&lt;h6&gt;</code>、 <code>&lt;from&gt;</code>、<code>&lt;canvas&gt;</code> 等。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements#%E5%85%83%E7%B4%A0%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">点击查看</a>所有的块级元素清单。</p><p>⚠️ 需要注意是，『块级元素』 和 <code>display</code> 为 <code>block</code> 的元素不是一个概念。例如，<code>&lt;li&gt;</code> 元素默认的 <code>display</code> 值是 <code>list-item</code>，<code>&lt;table&gt;</code> 元素默认的 <code>display</code> 值是 <code>table</code>，但是它们均是 『块级元素』，因为它们都符合块级元素的基本特征，也就是一个水平流上只能单独显示一个元素，多个块级元素则换行显示。</p><p>正是由于『块级元素』具有换行特性，因此理论上它都可以配合 <code>clear</code> 属性来清除浮动带来的影响。例如:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  display: table; // 也可以是 block，或者是 list-item</span><br><span class="line">  <span class="selector-tag">clear</span>: <span class="selector-tag">both</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>inline-block</code> 的实现方式，外在盒子负责元素是可以一行显示，还是只能换行显示;内在盒子负责宽高、内容呈现什么的。<code>width/height</code> 作用在内在盒子上。</p><p>按照 <code>display</code> 的属性值不同，值为 <code>block</code> 的元素的盒子实际由外在的 “块级盒子”和内在的“块级容器盒子”组成，值为 <code>inline-block</code> 的元素则由外在的“内联盒子”和内在的“块级容器盒子”组成，值为 <code>inline</code> 的元素则内外均是“内联盒子”。</p><h2 id="width-height"><a href="#width-height" class="headerlink" title="width/height"></a>width/height</h2><p>width 的默认值是 auto，会有以下 4种宽度表现：</p><p>(1)充分利用可用空间。比方说，<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code> 这些元素的宽度默认是 100% 于父级容器的。 像水流充满容器。</p><p>(2)收缩与包裹。典型代表就是浮动、绝对定位、inline-block 元素或 table 元素，</p><p>(3)收缩到最小。这个最容易出现在 table-layout 为 auto 的表格中</p><p>(4) 超出容器限制。除非有明确的 width 相关设置，否则上面 3 种情况尺寸都不会主动超过父级容器宽度的，但是存在一些特殊情况。例如，内容很长的连续的英文和数字，或者内联元素被设置了 <code>white-space:nowrap</code>。</p><p>一般会终止于空格(普通空格)、短横线、问号以及其他非英文字符等。例如，“display:inline-block”这几个字符以连接符“-”作为分隔符，形成了“display:inline”和“block”两个连续单元。</p><p><code>&lt;button&gt;</code> 标签按钮才会自动换行，<code>&lt;input&gt;</code> 标签按钮，默认 <code>white-space:pre</code>，是不会换行的，需要将 <code>pre</code> 值重置为默认的 <code>normal</code>。</p><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><p>宽度是作用在 <code>content box</code> 上的，而外面围绕的 <code>padding box</code> 和 <code>border box</code> 又不是摆设。</p><p><code>box-sizing:border-box</code> 就是让 100 像素的宽度直接作用在 <code>border box</code> 上，从默认的 <code>content box</code> 变成 <code>border box</code>。</p><p>在 CSS 世界中，唯一离不开 <code>box-sizing:border-box</code> 的就是原生普通文本框 <code>&lt;input&gt;</code> 和文本域 <code>&lt;textarea&gt;</code> 的 100% 自适应父容器宽度。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">textarea</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">-ms-box-sizing</span>: border-box; <span class="comment">/* for IE8 */</span></span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>box-sizing</code> 被发明出来最大的初衷应该是解决替换元素宽度自适应问题。</p><p>如果真的如我所言，那 <code>*{box-sizing:border-box}</code> 是不是没用在点儿上呢?是不是应该像下面这样 CSS 重置才更合理呢?</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">  <span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, <span class="selector-tag">img</span>, <span class="selector-tag">video</span>, <span class="selector-tag">object</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elemente#Elements" target="_blank" rel="noopener">所有内联元素清单</a></p><h3 id="幽灵空白节点"><a href="#幽灵空白节点" class="headerlink" title="幽灵空白节点"></a>幽灵空白节点</h3><p>“幽灵空白节点”指的是在 HTML5 文档声明中，<strong>内联元素</strong>的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。</p><p><a href="https://www.w3.org/TR/CSS2/visudet.html#leading" target="_blank" rel="noopener">w3c 幽灵节点相关内容</a></p><p>规范里叫 <code>strut</code></p><p>⚠️ 注意，文档声明必须是 HTML5 文档声明，如果还是很多年前的老声明，则不存在“幽灵空白节点”。</p><p>我们可以举一个最简单的例子证明“幽灵空白节点”确实存在， CSS 和 HTML 代码如下:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#cd0000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  display: inline-block; // 如果内联元素内什么都没有，也不会出现。所以设置了 inline-block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;长度单位&quot;&gt;&lt;a href=&quot;#长度单位&quot; class=&quot;headerlink&quot; title=&quot;长度单位&quot;&gt;&lt;/a&gt;长度单位&lt;/h2&gt;&lt;h3 id=&quot;相对长度单位&quot;&gt;&lt;a href=&quot;#相对长度单位&quot; class=&quot;headerlink&quot; title=&quot;相对长度单
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 文件的异步加载 async 和 defer</title>
    <link href="https://hufangyun.com/2018/js-async/"/>
    <id>https://hufangyun.com/2018/js-async/</id>
    <published>2018-11-05T07:32:06.000Z</published>
    <updated>2019-03-06T23:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 webpack 等工具的照料下，我们忘记了很多的东西，比如说 JavaScript 文件的异步加载，异步执行等等内容。唯一能记起是关于 script 的优化可能是把 script 标签放到页面底部。</p><p>某次你看到 ‘<script src="mylib.js" async></script>‘ 这样的引入语句，请问这 async 到底是什么意义呢？</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>1、学习 async 的作用，使用限制等。</p><p>2、有没有其他类似的属性呢？</p><h2 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h2><p>性能优化</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>聊 JavaScript 文件的异步加载之前，我们先来看一段 HTML 文档的加载流程。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://a.com/a.js"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="undefined">  这里有很多的 HTML 标签和内容</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>对于上面的 HTML 文档，浏览器的解析过程如下：</p><p>1、浏览器一边下载 HTML 网页，一边开始解析(并不是下载完之后，才开始开始解析)。</p><p>2、解析过程中，浏览器发现 <code>&lt;script&gt;</code> 标签就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</p><p>3、如果 <code>&lt;script&gt;</code> 标签引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</p><p>4、JavaScript 引擎执行完毕，控制权交还渲染引擎，继续解析 HTML 网页。</p><p>加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后再继续渲染。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g0u4n0mieqj30it04y3yb.jpg" alt=""></p><p>这就是为什么我们一般建议把 <code>&lt;script&gt;</code> 标签放在 <code>&lt;/body&gt;</code> 之前，而不是放在 <code>&lt;head&gt;&lt;/head&gt;</code> 中，因为加载 <code>&lt;script&gt;</code> 中的脚本并执行会阻塞 HTML 页面的渲染，当 JavaScript 文件很大的时候，甚至会长时间出现白屏。</p><p>有没有什么办法可以优化 JavaScript 文件的加载执行，提高页面加载的效率？</p><h2 id="解读-async-和-defer-属性"><a href="#解读-async-和-defer-属性" class="headerlink" title="解读 async 和 defer 属性"></a>解读 async 和 defer 属性</h2><p>翻阅 <a href="https://www.w3.org/TR/html51/semantics-scripting.html" target="_blank" rel="noopener">HTML5 的文档</a> 就会发现，<code>&lt;script&gt;</code> 还有 <code>async</code> 和 <code>defer</code> 两个和脚本加载执行有关的属性。</p><blockquote><p>async - Execute script in parallel //并行执行脚本</p><p>defer - Defer script execution // 延迟执行脚本</p></blockquote><p><a href="https://www.w3.org/TR/html4/interact/scripts.html#18.2.1" target="_blank" rel="noopener">HTML4.1</a>是这么解释 defer 的：</p><blockquote><p>When set, this boolean attribute provides a hint to the user agent that the script is not going to generate any document content (e.g., no “document.write” in javascript) and thus, the user agent can continue parsing and rendering.</p></blockquote><p>就是说浏览器在遇到设置了 defer 的 <code>&lt;script&gt;</code> 时，加载了 JavaScript 文件后，不会立即执行，不会阻塞浏览器解析 HTML，而且如果设置了 defer 不要在 JavaScript 脚本里写 <code>document.write</code>。</p><p><a href="https://www.w3.org/TR/html51/semantics-scripting.html" target="_blank" rel="noopener">HTML5.1</a>这么解释 defer 和 async 的：</p><p>此处省略将近 1500 字的英文引用，感兴趣点击的 <a href="https://www.w3.org/TR/html51/semantics-scripting.html" target="_blank" rel="noopener">HTML5.1</a> 文档。</p><p>对省略的原文总结如下：</p><p>1、defer 和 async 只对外部加载的脚本有效果，<code>&lt;script&gt;</code> 包含的 JavaScript 代码块无效。</p><p>2、必须设置了 <code>src</code> 属性，不然 defer 和 async 也无效。</p><p>3、defer 和 async 这两个值是布尔类型的。</p><p>4、如果设置了 async 属性，会并行加载脚本文件并执行，下载时不会阻塞 HTML 的解析，但是脚本执行的时候会阻塞 HTML 的解析。如果没有设置 async 属性，但是设置了 defer 属性，也会并行加载脚本文件，但是会等到页面完成解析再去执行。如果这两个属性都没有设置，会阻塞页面解析，加载并执行脚本文件。三种方式的对比图如下：</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g0u4yijbn8j315s082q2z.jpg" alt="图片来源：www.w3c.org"><span class="img-alt">图片来源：www.w3c.org</span></p><p><a href="https://www.w3.org/TR/html53/semantics-scripting.html#element-attrdef-script-defer" target="_blank" rel="noopener">HTML5.3</a>的文档把第四条补充了一下。。。</p><p>1、defer 对 module 脚本是无效的，但是 async 是有效的</p><p>2、如果同时设置了 defer 和 async 为 true， 以 defer 为准</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>通过给 <code>&lt;script&gt;</code> 标签设置 defer 属性，将脚本文件设置为延迟加载，当浏览器遇到带有 defer 属性的 <code>&lt;script&gt;</code> 标签时，会再开启一个线程去下载 JavaScript 文件，同时继续解析 HTML 文档，等 HTML 全部解析完毕 DOM 加载完成之后(也就是DOMContentLoaded 事件之后 onload 事件之前)，再去执行加载好的 JavaScript 文件。多个js文件的执行顺序就是它们在页面中出现的顺序。</p><p>async 属性和 defer 属性类似，也是会开启一个线程去下载 JavaScript 文件，但和defer 不同的是，它会在下载完成后立刻执行，而不是会等到 DOM 加载完成之后再执行，所以还是有可能会造成阻塞。对多个带有 async 的 JavaScript 文件，它不能像defer 那样保证按顺序执行，它是哪个 JavaScript 文件先下载完就先执行哪个。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>什么时候用 defer，什么时候用 async 呢？</p><p>一般来说，两者之间的选择则是看脚本之间是否有依赖关系，有依赖的话应当要保证执行顺序，应当使用 defer 没有依赖的话使用 async。要注意的是两者都不应该使用 <code>document.write</code>，这个导致整个页面被清除。</p><p>模块化的代码、测试代码或者监听代码使用 async。</p><p>这两个值是布尔类型的，在 HTML 里面只写属性名即可。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://a.com/a.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span></span><br></pre></td></tr></table></figure><p>如果不考虑兼容 IE 浏览器，完全可以将 <code>&lt;script&gt;</code> 放在 <code>&lt;head&gt;</code> 里，同时守设置 defer 属性，这样 HTML 解析的时候，可以并行下载 JavaScript 脚本，等 HTML 页面解析完，JavaScript 脚本在开始执行，充分利用资源。比如查看 gitlab 页面源码。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>defer 是 HTML4 就有的属性，而 async 是 HTML5 新加入的属性。defer 出现的早，IE6 及以上的浏览器基本都支持，可以放心用。 async IE10 就开始支持了，移动端的支持比较好。不考虑 IE 的话，两个属性都可以放心使用。</p><p>兼容性可以点击这里查看<a href="https://caniuse.com" target="_blank" rel="noopener">caniuse</a></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>如果同时设置了 defer 和 async 为 true，浏览器会怎么执行？</p><p>我们做个小实验。</p><p>新建一个文件夹，文件结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── 1.js</span><br><span class="line">├── 2.js</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure><p>1.js 如下:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>2.js 如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>index.html 的内容如下：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"./1.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"./2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试 async 和 defer <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  alert(3);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>设置两个 js 是为了排除 async 和 defer 先后顺序的影响。</p><p>FireFox、Chrome、Safari、三个浏览器的执行结构都是 3、1、2，说明同时设置了 defer 和 async 为 true， 以 defer 为准。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html" target="_blank" rel="noopener">async vs defer attributes</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.im/post/5bcdaed7e51d457a8254e1b7" target="_blank" rel="noopener">网页性能优化之异步加载js文件 - 掘金</a></p><p><a href="https://www.w3.org/TR/html4/interact/scripts.html#18.2.1" target="_blank" rel="noopener">HTML4.1</a></p><p><a href="https://www.w3.org/TR/html51/semantics-scripting.html" target="_blank" rel="noopener">HTML5.1</a></p><p><a href="https://www.w3.org/TR/html53/semantics-scripting.html#element-attrdef-script-defer" target="_blank" rel="noopener">HTML5.3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在 webpack 等工具的照料下，我们忘记了很多的东西，比如说 JavaScript 文件的异步加载，异步执行等等内容。唯一能记起是关于 
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>如何修改 git 已提交的用户邮箱和用户名</title>
    <link href="https://hufangyun.com/2018/git-change-user-info/"/>
    <id>https://hufangyun.com/2018/git-change-user-info/</id>
    <published>2018-09-19T11:44:04.000Z</published>
    <updated>2018-09-19T11:44:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fh37ua0t32j30nc08caav.jpg" alt=""></p><h3 id="1、修改上一次提交的邮箱和用户名"><a href="#1、修改上一次提交的邮箱和用户名" class="headerlink" title="1、修改上一次提交的邮箱和用户名"></a>1、修改上一次提交的邮箱和用户名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend --reset-author</span><br></pre></td></tr></table></figure><h3 id="2、批量修改多次提交的邮箱和用户名"><a href="#2、批量修改多次提交的邮箱和用户名" class="headerlink" title="2、批量修改多次提交的邮箱和用户名"></a>2、批量修改多次提交的邮箱和用户名</h3><p>新建一个 <code>shell</code> 脚本 <code>changeGitInfo.sh</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">git filter-branch --env-filter <span class="string">'</span></span><br><span class="line"><span class="string">an="$GIT_AUTHOR_NAME"</span></span><br><span class="line"><span class="string">am="$GIT_AUTHOR_EMAIL"</span></span><br><span class="line"><span class="string">cn="$GIT_COMMITTER_NAME"</span></span><br><span class="line"><span class="string">cm="$GIT_COMMITTER_EMAIL"</span></span><br><span class="line"><span class="string">if [ "$GIT_COMMITTER_EMAIL" = "这里写你原来的邮箱" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">cn="你想替换成的用户名"</span></span><br><span class="line"><span class="string">cm="你想替换成的邮箱"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">if [ "$GIT_AUTHOR_EMAIL" = "这里写你原来的邮箱" ]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">an="你想替换成的用户名"</span></span><br><span class="line"><span class="string">am="你想替换成的邮箱"</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string">export GIT_AUTHOR_NAME="$an"</span></span><br><span class="line"><span class="string">export GIT_AUTHOR_EMAIL="$am"</span></span><br><span class="line"><span class="string">export GIT_COMMITTER_NAME="$cn"</span></span><br><span class="line"><span class="string">export GIT_COMMITTER_EMAIL="$cm"</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure><p>在 <code>git</code> 仓库(项目)下运行一下，该脚本即可。</p><h2 id="如果避免上面的问题？"><a href="#如果避免上面的问题？" class="headerlink" title="如果避免上面的问题？"></a>如果避免上面的问题？</h2><h3 id="分目录配置-git-用户信息"><a href="#分目录配置-git-用户信息" class="headerlink" title="分目录配置 git 用户信息"></a>分目录配置 git 用户信息</h3><p><code>git</code> 可以设置全局的用户信息，然后可以再单独为每个仓库设置用户信息。如果忘记了给项目重置用户信息，可能就会发生上面的问题 — 提交时的邮箱和用户名错了。😓</p><p>如果你喜欢用不同的目录区分个人和公司的项目，可以使用下面的方法配置自己的 <code>git</code> 用户信息。😀</p><p>比如，你把公司的项目都放在了 <code>Company</code> 目录下，个人的项目都放在了 <code>Personal</code> 目录下下面。</p><p>那你可以这么做：</p><p>在 <code>Company</code> 下新建一个 <code>.gitconfig_include</code> 文件，配置你想在该目录下给所有 <code>git</code> 仓库设置的用户信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[user]</span><br><span class="line">  name = 用户名</span><br><span class="line">  email = 邮箱</span><br></pre></td></tr></table></figure><p>然后在 <code>~/.gitconfig</code> 内添加</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[includeIf &quot;gitdir:~/Company/&quot;]</span><br><span class="line">  path = ~/Company/.gitconfig_include</span><br></pre></td></tr></table></figure><p>⚠️ 复制提醒。<code>Company</code> 要替换成你自己的目录</p><p>这样，之后 <code>Company</code> 目录下的 <code>git</code> 仓库都会使用对应的 <code>git</code> 用户信息。💪</p><p>这是 git 的一个用法，感兴趣的同学可以看这里 <a href="https://git-scm.com/docs/git-config#_conditional_includes" target="_blank" rel="noopener">conditional includes </a> </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/21307793/set-git-config-values-for-all-child-folders" target="_blank" rel="noopener">Set git config values for all child folders</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79ly1fh37ua0t32j30nc08caav.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、修改上一次提交的邮箱和用户名&quot;&gt;&lt;a href=&quot;#1、修改上一次提交的邮箱
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>ESLint 的禁用规则</title>
    <link href="https://hufangyun.com/2018/eslint-disable/"/>
    <id>https://hufangyun.com/2018/eslint-disable/</id>
    <published>2018-08-08T06:57:05.000Z</published>
    <updated>2019-01-28T06:57:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有些情况下，对于某些代码，我们该怎么禁用 ESLint 代码规范检查呐？</p></blockquote><p><a href="https://eslint.org/docs/user-guide/configuring.html#configuring-rules" target="_blank" rel="noopener">官方文档</a></p><h2 id="禁用方法"><a href="#禁用方法" class="headerlink" title="禁用方法"></a>禁用方法</h2><p>代码块禁用</p><p>1、</p><ul><li><code>&quot;off&quot;</code> 或者 <code>0</code> - 关掉规则</li><li><code>&quot;warn&quot;</code> 或者 <code>1</code> - 打开规则作为一个警告(不影响退出代码)</li><li><code>&quot;error&quot;</code> 或者 <code>2</code> - 打开规则作为一个错误(退出代码为1时触发)</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* eslint react/display-name: 0, curly: 2 */</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; */</span><br></pre></td></tr></table></figure><p>2、禁用所有规则<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*eslint-disable */</span><br><span class="line"></span><br><span class="line">code...</span><br><span class="line"></span><br><span class="line">/*eslint-enable */</span><br></pre></td></tr></table></figure></p><p>3、禁用指定的规则</p><blockquote><p>多个规则间用逗号分隔</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*eslint-disable no-alert, no-console */</span><br><span class="line"></span><br><span class="line">code...</span><br><span class="line"></span><br><span class="line">/*eslint-enable */</span><br></pre></td></tr></table></figure><p>单行代码禁用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code... // eslint-disable-line</span><br><span class="line"></span><br><span class="line">code... // eslint-disable-line no-alert, quotes</span><br></pre></td></tr></table></figure><p>禁用下一行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code...</span><br><span class="line">// eslint-disable-next-line no-alert, quotes</span><br></pre></td></tr></table></figure></p><h2 id="禁用的规则名哪里找？"><a href="#禁用的规则名哪里找？" class="headerlink" title="禁用的规则名哪里找？"></a>禁用的规则名哪里找？</h2><p>ESLint 在终端提示的信息里就有对应的 rule-name</p><p><img src="/media/15337126571518.jpg" alt="-w493"><span class="img-alt">-w493</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有些情况下，对于某些代码，我们该怎么禁用 ESLint 代码规范检查呐？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://eslint.org/docs/user-guide/configuring.html#confi
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>《东京一年》读书笔记</title>
    <link href="https://hufangyun.com/2018/book-a-year-in-tokyo/"/>
    <id>https://hufangyun.com/2018/book-a-year-in-tokyo/</id>
    <published>2018-07-30T13:19:59.000Z</published>
    <updated>2018-07-30T13:19:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>蒋方舟的<a href="https://book.douban.com/subject/27074861/" target="_blank" rel="noopener">《东京一年》</a></p><blockquote><p>“眼前苟且”与“诗和远方”是一对虚假的对立。我在东京一年的生活表面看是“诗和远方”，生活在迷人的异域，鸡毛蒜皮消失了，可东京的生活同样存在着无奈的人性、琐碎的沟通、窘迫的算计与虚伪的寒暄。另外，网络的发达让“远方”的概念消失了，我身在异国，却时刻关注着国内的人与事，为我触手而不可及的苦难感到悲伤。正是这些并不美好的细节，才构成了生活的全部。</p></blockquote><blockquote><p>她说，在30岁的时候抛下国内的一切来日本生活是她做过最正确的决定。大多数时候，我都觉得人们的这种说法是种自我保护，因为生活的沉没成本太高——那些逝去的时间、精力的投入、对别的人生选择的牺牲都无法挽救，所以只能给自己的人生选择寻找合理化的解释。但D小姐说的话我相信，相信她不是自我辩护。</p></blockquote><p>人生有很多的选择和生活方式。日复一日的上班工作不一定就是眼前的苟且，环游世界和自由职业也不一定是诗和远方。有时候工作中接到一些无聊需求时，我就在想以后成为自由职业者多好啊。每天自由支配自己的时间，开发自己的应用。但是后来和一些自由职业者交流时发现，也并没有想象中的那么美好，所有的事物都有两面性，有利有弊。最重要的是，时不时的问问内心，自己想要的是什么？</p><p>我内心想要的是什么？</p><ul><li><p>有点钱，不为钱所困。</p></li><li><p>投入一份自己喜欢的事业。</p></li><li><p>接触更多的可能性。</p></li></ul><p>用蒋方舟的话说就是: 我还是一个如此功利和虚荣的人，畏惧平稳生活带来的安逸，只能从进步里获得对自己的认可，感知到自己在活着。</p><blockquote><p>面容同老式做派的反差，真遇到爱做古体诗并高声朗读的老干部，谁还爱得起来？</p></blockquote><p>爱的是大叔的容颜和岁月带给他们的成熟与社会地位</p><blockquote><p>高浓度的青春逐渐变得稀薄，是从同伴的不断失落开始。这种失落不一定是失联，抑或是志趣道路发生变化。谈话交心往往陷入对彼此生活选择的不赞同，为了不破坏已经伤痕累累的情感联系，索性变得越来越沉默，终于相对无言。</p></blockquote><p>两种朋友</p><ul><li>渐渐的形同陌路，相处见面，成了努力的寻找话题，避免尴尬。</li><li>往日的友情，残留的温度，牵绊。</li></ul><blockquote><p>天真的人很容易世故，某种程度上，天真和世故并不是矛盾的特质，而往往出现在一个人身上的不同阶段。天真的人不懂得珍惜这个特质，而是早早地把它当作成长必然蜕掉的皮，轻率地抛弃在一边。抑或像小孩子，走一路采了一路的花，采花时也显得兴致勃勃，充满乐趣，到了路的尽头却毫不在意地把那一捧花向上一撒，扔掉，迅速变得世故。<br>而成年后还小心翼翼地呵护着自己天真一面的人，本质则是复杂的——至少是见过复杂，才知道天真有多可贵。</p></blockquote><blockquote><p>我喜欢鲁迅的一句诗：“当我沉默的时候，我觉得很充实；当我开口说话，就感到了空虚。”</p></blockquote><blockquote><p>我喜欢奥登的一首诗：“我们如何指望群星为我们燃烧？/带着那我们不能回报的激情？/如果爱不能相等/让我成为那爱得更多的一个。”</p></blockquote><p>我以前也认为小说家是靠灵感写作，没想到写作的时候比上班族还累，可能还会导致婚姻 家庭破裂</p><blockquote><p>很多人认为“自律”是自我压抑的结果，“存天理，灭人欲”，变成一个苦行僧。但其实自律不是压抑之后的被动选择，而是个体意识的主动选择。自律的人意识到自己内心的冲动和外界标准的冲突，然后开始主动调整自己。调整自己的身体也是一种控制力的练习。</p></blockquote><blockquote><p>在非正义的历史之中的每个人，都兼具受害者和施害者的双重身份。<br>《耻》写了一个让人不愿意接受的故事，像是《冰与火之歌》里说的“All Men Must Die（凡人皆死）”，只要你曾经身处一段耻辱的历史中，不管你扮演什么样的角色，你必须接受自己所有的尊严也被抹杀掉的事实。</p></blockquote><blockquote><p>那么出路是什么？</p></blockquote><blockquote><p>我总认为伟大的作品在写尽了人类已经到来和逐渐到来的苦难之后，总会提供一道窄门。就像《圣经》中耶稣说：“你们要进窄门。因为引到灭亡，那门是宽的，路是大的，进去的人也多；引到永生，那门是窄的，路是小的，找着的人也少。”<br>可库切并不是一个宗教作家，他并不把宗教救赎视为答案。他在小说中提供了一个人类自我救赎的方式：平等地对待动物。<br>在库切的几乎所有作品中，他都会提到动物的权利，他甚至写了本叫作《动物的生命》的小书。在库切看来，人们把动物划分为完全外在于自我并且低于自己的物种，是一种最深层的不平等。只要人类对动物的巧取豪夺没有结束，人类的其他不平等就不会结束，历史耻辱的循环就不会停止。</p></blockquote><blockquote><p>库切确实为小说中绝望的人们提供了解药，但这解药简直比绝望本身更让人绝望。</p></blockquote><blockquote><p>尼采说：“我们有艺术，所以我们不会因真相而死。”库切说：“南非有太多真相让艺术去把握……淹没了想象的每个角落。”</p></blockquote><blockquote><p>那我们呢？身处太多真相中的中国写作者，该如何让想象喘口气？又该如何真正摆脱耻，安居于一个真正拥有立足之地的世界呢？</p></blockquote><blockquote><p>小说的结尾，已经宣布弃教的洛特里哥的一段自述，让小说之前累积的信仰危机与苦难化作一股排山倒海的力量，击打着读者的心，那种情感的强度是我很多年不曾感受到的。洛特里哥接受了出卖他的吉次郎的忏悔，对自己说：<br>“在这个国家，我现在仍然是最后的天主教司祭。而，那个人（上帝）并非是沉默着。纵使那个人是沉默着，到今天为止，我的人生本身就在诉说着那个人。”</p></blockquote><blockquote><p>谈起创作《沉默》这本小说的初衷，远藤周作写下：“我并不关注那些光荣殉教的强者，而是将目光投向那些惧怕肉体折磨、害怕死亡、卑微怯懦、因一心拯救家族成员而放弃信仰最终踏上踏板的弱者。我要使他们重新从历史的尘埃中苏醒过来，在这个世界上昂首阔步地行走，倾听他们的声音，这只有文学家可以做到。”</p></blockquote><blockquote><p>而去年一年，每每遇到世间荒诞无常的事，我总想起《旧约·诗篇》中的一句诗：“我们经过的日子都在你的震怒之下/我们度尽的年岁好像一声叹息。”<br>——是无助吧，希冀一个更大的力量在目睹这世上发生的一切，即便他决计不施以援手，但他心中有数。</p></blockquote><p>无力改变现实的无助，使人们将希望寄托于神。想让神做出判决，让正义战胜邪恶😈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;蒋方舟的&lt;a href=&quot;https://book.douban.com/subject/27074861/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《东京一年》&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“眼前苟且”与“诗和远方”是一对虚假的
      
    
    </summary>
    
      <category term="读书" scheme="https://hufangyun.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>我的技术书单</title>
    <link href="https://hufangyun.com/2018/book-tech-my/"/>
    <id>https://hufangyun.com/2018/book-tech-my/</id>
    <published>2018-07-05T02:49:18.000Z</published>
    <updated>2018-07-05T02:49:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🙉 是左耳朵耗子（陈皓） 推荐的书籍<br>📖 是在读的书籍<br>📕 是已读的书籍</p></blockquote><h3 id="专业基础"><a href="#专业基础" class="headerlink" title="专业基础"></a>专业基础</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>算法图解 🙉 📖</p><p>算法 🙉</p><p>算法导论 🙉</p><p>编程珠玑 🙉</p><p>数据结构与算法分析 🙉</p><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>数据库系统概念 🙉</p><p>现代操作系统 🙉</p><p>计算机网络 🙉 📖</p><p>计算机程序的构造和解释 🙉</p><p>编译原理 🙉</p><p>深入理解计算机系统 🙉</p><p>Wireshark 数据包分析实战 🙉</p><p>Unix 高级环境编程 🙉</p><p>Unix 网络编程 第 1 卷 套接口 API 、第 2 卷 进程间通信 🙉</p><p>TCP/IP 详解 卷 I 协议 🙉</p><blockquote><p>如果上面的三本看不懂，可以先看是下面的三本</p></blockquote><p>Linux C 编程一站式学习 🙉</p><p>TCP/IP 网络编程 🙉</p><p>图解 TCP/IP 🙉</p><p>The TCP/IP Guide 🙉</p><h3 id="程序员修养"><a href="#程序员修养" class="headerlink" title="程序员修养"></a>程序员修养</h3><p>重构 改善既有代码的设计 🙉 📕</p><p>修改代码的艺术 🙉</p><p>代码整洁之道 🙉 📕</p><p>程序员的职业素养 🙉</p><p>程序员的思维修炼 📕</p><h3 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h3><h4 id="CSS-类"><a href="#CSS-类" class="headerlink" title="CSS 类"></a>CSS 类</h4><p>CSS世界 📖</p><p>CSS实战手册（第四版）8.4</p><p>CSS权威指南（第三版）8.5</p><p>精通CSS（第2版）8.7</p><h4 id="JavaScript-类"><a href="#JavaScript-类" class="headerlink" title="JavaScript 类"></a>JavaScript 类</h4><p>JavaScript DOM 编程艺术（第二版）</p><p>JavsScript高级程序设计</p><p>编写可维护的JavaScript</p><p>高性能网站建设指南</p><p>深入浅出 React 和 Redux 📖</p><p>你不知道的JavaScript</p><p>ECMAScript 6入门(全彩)</p><p>JavaScript语言精粹</p><p>JavaScript权威指南</p><p>高性能JavaScript</p><p>JavaScript设计模式</p><p>Effective JavaScript:编写高质量JavaScript代码的68个有<br>效方法</p><p>JavaScript框架设计</p><h3 id="UI交互"><a href="#UI交互" class="headerlink" title="UI交互"></a>UI交互</h3><p>写给大家看的设计书 📖</p><p>30天学会绘画</p><p>文字设计的原理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;🙉 是左耳朵耗子（陈皓） 推荐的书籍&lt;br&gt;📖 是在读的书籍&lt;br&gt;📕 是已读的书籍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;专业基础&quot;&gt;&lt;a href=&quot;#专业基础&quot; class=&quot;headerlink&quot; title=&quot;专业基础
      
    
    </summary>
    
      <category term="读书" scheme="https://hufangyun.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>从哪里了解 Google Chrome 升级的新特性</title>
    <link href="https://hufangyun.com/2018/chrome-update-know/"/>
    <id>https://hufangyun.com/2018/chrome-update-know/</id>
    <published>2018-06-26T11:36:25.000Z</published>
    <updated>2018-06-26T11:36:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Google-Chrome-canary-dev-beta-stable-4-个版本的区别"><a href="#Google-Chrome-canary-dev-beta-stable-4-个版本的区别" class="headerlink" title="Google Chrome canary dev beta stable 4 个版本的区别"></a>Google Chrome canary dev beta stable 4 个版本的区别</h2><p><strong> 开发流程是这样的 </strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">canary -&gt; dev -&gt; beta -&gt; stable</span><br></pre></td></tr></table></figure><p><img src="/media/ustream-techtalks-google-chrome-developer-tools-5-638.jpg" alt="ustream-techtalks-google-chrome-developer-tools-5-638"><span class="img-alt">ustream-techtalks-google-chrome-developer-tools-5-638</span></p><p><code>canary</code> 是最激进的，几乎每天都更新。</p><p><code>stable</code> 是稳定版，是面向普通用户，平均六个月更新一次</p><p><code>canary</code> 和 <code>stable</code> 会相差 2 个左右的版本。比如 <code>stable</code> 版本现在（2018年6月26日）是 67，<code>canary</code> 现在是 69。</p><p><img src="/media/C12Q3aEWgAAwhBE.jpg" alt="C12Q3aEWgAAwhBE"><span class="img-alt">C12Q3aEWgAAwhBE</span></p><h2 id="Chromium-和-Chrome-的区别"><a href="#Chromium-和-Chrome-的区别" class="headerlink" title="Chromium 和 Chrome 的区别"></a>Chromium 和 Chrome 的区别</h2><ul><li><p><code>Chromium</code> 是一个开源的浏览器。 </p></li><li><p><code>Chrome</code> 是基于 <code>Chromium</code> 而来。</p></li><li><p><code>Chromium</code> 更新速度和 <code>canary</code> 是一致的。</p></li><li><p><code>Chromium</code> 作为一个开源项目去掉了一些不开源的东西，比如 <code>Google</code> 的标识和 <code>flash</code> 插件等等。 </p></li></ul><h2 id="从哪里可以看到-Chrome-的更新"><a href="#从哪里可以看到-Chrome-的更新" class="headerlink" title="从哪里可以看到 Chrome 的更新"></a>从哪里可以看到 Chrome 的更新</h2><h3 id="Canary-版"><a href="#Canary-版" class="headerlink" title="Canary 版"></a>Canary 版</h3><p><code>Canary</code> 版 几乎每天都更新，但是没有更新日志。只能通过源码的提交记录查看。<a href="https://chromium.googlesource.com/chromium/src/" target="_blank" rel="noopener">项目地址</a></p><p>然后找到 <code>tags</code> 比如 [<code>69.0.3473.1</code>]</p><p>新页面里点击 <code>log</code> 即可查看每次的提交</p><h2 id="Dev-版"><a href="#Dev-版" class="headerlink" title="Dev 版"></a>Dev 版</h2><p><a href="https://blog.chromium.org/" target="_blank" rel="noopener">https://blog.chromium.org/</a></p><h2 id="Stable-版"><a href="#Stable-版" class="headerlink" title="Stable 版"></a>Stable 版</h2><p><a href="https://chromereleases.googleblog.com/" target="_blank" rel="noopener">https://chromereleases.googleblog.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Google-Chrome-canary-dev-beta-stable-4-个版本的区别&quot;&gt;&lt;a href=&quot;#Google-Chrome-canary-dev-beta-stable-4-个版本的区别&quot; class=&quot;headerlink&quot; title=&quot;Go
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>提升效率的小工具分享</title>
    <link href="https://hufangyun.com/2018/efficient-small-tools/"/>
    <id>https://hufangyun.com/2018/efficient-small-tools/</id>
    <published>2018-06-18T23:17:41.000Z</published>
    <updated>2018-06-18T23:17:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>哈哈 😝 ，碰到好的工具总是忍不住要和大家分享一下</p></blockquote><p> git-open</p><blockquote><p><code>zsh</code> 插件。在终端快速打开 <code>git</code> 项目主页。 详情请看<a href="https://hufangyun.com/2017/zsh-plugin/">这篇博文</a></p></blockquote><p> gitlab</p><blockquote><p>Alfred workflow gitlab 插件。快速打开 项目地址。<a href="https://github.com/lukewaite/alfred-gitlab" target="_blank" rel="noopener">下载地址</a></p></blockquote><p> chrome 的 device</p><blockquote><p>chrome 设置 <code>UA</code> 模拟设备。 可以设置在微信环境内、iOS app 内。</p></blockquote><p> dash</p><blockquote><p>代码片段功能</p></blockquote><p> trash</p><blockquote><p>删除文件到系统的垃圾桶。防止 <code>rm</code> 错删文件，无法找回 <a href="https://github.com/sindresorhus/trash" target="_blank" rel="noopener">trash 官网</a></p></blockquote><p> onetab</p><blockquote><p>chrome 插件 暂存打开的标签页</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;哈哈 😝 ，碰到好的工具总是忍不住要和大家分享一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; git-open&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;zsh&lt;/code&gt; 插件。在终端快速打开 &lt;code&gt;git&lt;/code&gt; 项
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>几个不错的 App 设计网站</title>
    <link href="https://hufangyun.com/2018/ui-design-get/"/>
    <id>https://hufangyun.com/2018/ui-design-get/</id>
    <published>2018-06-14T11:13:39.000Z</published>
    <updated>2018-06-30T16:28:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://hufangyun.com">小猿大圣</a>的 UI 学习自留地</p></blockquote><h2 id="sketchappsources"><a href="#sketchappsources" class="headerlink" title="sketchappsources"></a>sketchappsources</h2><p><a href="https://www.sketchappsources.com/" target="_blank" rel="noopener">https://www.sketchappsources.com/</a></p><p><img src="/media/15289473088372.jpg" alt=""></p><h2 id="dribbble"><a href="#dribbble" class="headerlink" title="dribbble"></a>dribbble</h2><p><a href="https://dribbble.com/" target="_blank" rel="noopener">https://dribbble.com/</a></p><p><img src="/media/15289473603818.jpg" alt=""></p><h2 id="sketchrepo"><a href="#sketchrepo" class="headerlink" title="sketchrepo"></a>sketchrepo</h2><p><a href="https://sketchrepo.com/" target="_blank" rel="noopener">https://sketchrepo.com/</a></p><p><img src="/media/15289475696821.jpg" alt=""></p><h2 id="uipixels"><a href="#uipixels" class="headerlink" title="uipixels"></a>uipixels</h2><p><a href="http://www.uipixels.com/" target="_blank" rel="noopener">http://www.uipixels.com/</a></p><p><img src="/media/15289475478955.jpg" alt=""></p><h2 id="UI-中国"><a href="#UI-中国" class="headerlink" title="UI 中国"></a>UI 中国</h2><p><a href="http://www.ui.cn/" target="_blank" rel="noopener">http://www.ui.cn/</a></p><h2 id="uplabs"><a href="#uplabs" class="headerlink" title="uplabs"></a>uplabs</h2><p><a href="https://www.uplabs.com/" target="_blank" rel="noopener">https://www.uplabs.com/</a></p><p><img src="/media/15289481019068.jpg" alt=""></p><h2 id="unsplash"><a href="#unsplash" class="headerlink" title="unsplash"></a>unsplash</h2><blockquote><p>图片</p></blockquote><p><a href="https://unsplash.com/" target="_blank" rel="noopener">https://unsplash.com/</a></p><h2 id="sketchactive"><a href="#sketchactive" class="headerlink" title="sketchactive"></a>sketchactive</h2><blockquote><p>图标</p></blockquote><p><a href="http://aegeank.com/sketchactive/" target="_blank" rel="noopener">http://aegeank.com/sketchactive/</a></p><p><img src="/media/15289474299421.jpg" alt=""></p><h2 id="创造狮"><a href="#创造狮" class="headerlink" title="创造狮"></a>创造狮</h2><blockquote><p>导航</p></blockquote><p><a href="http://chuangzaoshi.com/" target="_blank" rel="noopener">http://chuangzaoshi.com/</a></p><p><img src="/media/15289478996799.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://hufangyun.com&quot;&gt;小猿大圣&lt;/a&gt;的 UI 学习自留地&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;sketchappsources&quot;&gt;&lt;a href=&quot;#sketchappsources&quot; c
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库设计入门指南与学习笔记</title>
    <link href="https://hufangyun.com/2018/database-sql-design/"/>
    <id>https://hufangyun.com/2018/database-sql-design/</id>
    <published>2018-06-13T16:55:00.000Z</published>
    <updated>2018-08-08T16:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要记载我学习数据库设计过程中使用的学习资料和对相关知识的理解</p></blockquote><h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p><a href="https://www.imooc.com/video/1903" target="_blank" rel="noopener">慕课网的免费视频</a> 数据库设计那些事</p><blockquote><p><a href="https://coolshell.cn/haoel" target="_blank" rel="noopener">陈皓</a>在『左耳听风』专栏之程序员练级攻略（2018）里推荐的数据库入门资料</p></blockquote><h3 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h3><h4 id="什么是数据库设计？"><a href="#什么是数据库设计？" class="headerlink" title="什么是数据库设计？"></a>什么是数据库设计？</h4><p>根据<strong>业务需求</strong>，建立可以进行<strong>高效访问</strong>和<strong>高效存储</strong>的数据存储模型。（我自己的理解，不是定义哈 😂）</p><p>1、业务需求</p><p>2、高效的访问</p><p>3、高效的存储</p><h4 id="好的数据库设计是怎样的"><a href="#好的数据库设计是怎样的" class="headerlink" title="好的数据库设计是怎样的"></a>好的数据库设计是怎样的</h4><p>1、减少数据冗余 （相同的数据在多个地方存在）</p><p>2、避免数据维护异常（插入、更新、删除异常）</p><p>3、节约存储空间（省钱 💰）</p><p>4、高效的访问</p><h4 id="数据库设计的过程"><a href="#数据库设计的过程" class="headerlink" title="数据库设计的过程"></a>数据库设计的过程</h4><p>1、功能模块划分</p><p>2、分析各个模块的数据包括的那些属性、那些是可选的唯一标识</p><p>3、分析实体间的关系 1对1 1对多 多对多</p><p>4、使用ER图展示2、3步</p><p>5、分析数据的生命周期。永久存储（分表、分库）还是归档存储还是不归档存储（定期清理）</p><h4 id="使用ER图展示数据关系"><a href="#使用ER图展示数据关系" class="headerlink" title="使用ER图展示数据关系"></a>使用ER图展示数据关系</h4><p><img src="/media/15293168268240.jpg" alt=""></p><p><img src="/media/15293168822924.jpg" alt=""></p><h4 id="设计范式"><a href="#设计范式" class="headerlink" title="设计范式"></a>设计范式</h4><p>第一范式：字段是单一属性，不可再分，二维表。</p><p><img src="/media/15293255381312.jpg" alt=""></p><p>第二范式：供应商名称和商品名称放在一起，组合关键字，不要出现。</p><p><img src="/media/15293255732513.jpg" alt=""></p><p>第三范式：商品名称 -&gt; 分类名 -&gt; 分类描述 共存。</p><p><img src="/media/15293257830389.jpg" alt=""></p><p><img src="/media/15293256812047.jpg" alt=""></p><p>BC范式</p><p><img src="/media/15293258992402.jpg" alt=""></p><h4 id="字段类型的选择"><a href="#字段类型的选择" class="headerlink" title="字段类型的选择"></a>字段类型的选择</h4><p>1、当一个字段有多个类型可以选择的时候，优先选择数字类型、其次是日期和二进制，最后是字符类型。</p><p>2、如果列中要存储的数据长度差不多是一致的或者最大数据长度小于<code>50byte</code>优先使用 <code>char</code> 类型</p><p>3、<strong>char 与 varchar 的区别</strong></p><p>varchar 不固定长度，节省空间。</p><p>char 固定长度，但是储存快。</p><p><img src="/media/15293267820612.jpg" alt=""></p><p>4、主键的字段类型所占的空间要尽可能的小。</p><p>5、避免使用外键约束，会增加维护成本，但是在相关联的列上一定要建立索引</p><h4 id="维护和优化"><a href="#维护和优化" class="headerlink" title="维护和优化"></a>维护和优化</h4><p><img src="/media/15293275139331.jpg" alt=""></p><p><img src="/media/15293276627730.jpg" alt=""></p><p><img src="/media/15293278075195.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要记载我学习数据库设计过程中使用的学习资料和对相关知识的理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;入门篇&quot;&gt;&lt;a href=&quot;#入门篇&quot; class=&quot;headerlink&quot; title=&quot;入门篇&quot;&gt;&lt;/a&gt;入门篇&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>SMART目标成长法</title>
    <link href="https://hufangyun.com/2018/smart-goal/"/>
    <id>https://hufangyun.com/2018/smart-goal/</id>
    <published>2018-05-13T04:26:49.000Z</published>
    <updated>2018-05-13T04:26:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-🔗"><a href="#前言-🔗" class="headerlink" title="前言 🔗"></a>前言 🔗</h2><blockquote><p>目标是很美好的事情，你可能会有许多目标：减肥🏃‍♂️、找到一个更好的工作👔、搬进一个更大的房子🏡（或者更小的房子）、写本小说、学习演奏电吉他🎸、编写一个超级 <code>Rails</code> 应用程序或者完全掌握 <code>Erlang</code>。</p></blockquote><blockquote><p>但是很多目标都是一个模式——崇高的、泛泛的“我希望在某某方面更好”。减肥就是一个最好的例子🌰。</p></blockquote><blockquote><p>大多数人想要更苗条🧜‍♀️（特别是我们这些长时间坐在电脑前的人）。<br>但“我想要苗条”并不是一个非常明确的目标（虽然可能是一个很好的愿景——长期、理想的状态）。</p></blockquote><blockquote><p>你体重需要减多少斤？你仰卧举重准备练多少公斤的？何时完成？你准备控制热量还是增加锻炼？⚽️</p></blockquote><blockquote><p>类似地，说你想“学习 <code>Erlang</code> 是不错，但是这到底是什么意思？想要学到什么程度？想用它来做什么？如何开始？<br>为了帮助你专注于自己的目标，能够更好地实现它，请允许我推荐一种风靡一时的来自于咨询领域的诀窍：使用 <code>SMART</code> 方法实现你的目标。🥇</p></blockquote><p><img src="/media/20160621110804644.png" alt="20160621110804644"><span class="img-alt">20160621110804644</span></p><blockquote><p>图片取自 Google Image</p></blockquote><h2 id="什么是-SMART-💪"><a href="#什么是-SMART-💪" class="headerlink" title="什么是 SMART 💪"></a>什么是 <code>SMART</code> 💪</h2><p><strong><code>SMART</code> 代表具体的、可度量的、可实现的、相关的和时间可控的（Specific, Measurable, Achievable, Relevant, and Time-boxed）</strong></p><h3 id="具体的-✅"><a href="#具体的-✅" class="headerlink" title="具体的 ✅"></a>具体的 ✅</h3><p>首先，一个目标任务应该是具体的。也就是说，只说 “我想学习Erlang” 是不够的。应该把事情具体化，例如“我想要用Erlang编写一个可以动态生成内容的Web服务器”。</p><h3 id="可度量的-⏰"><a href="#可度量的-⏰" class="headerlink" title="可度量的 ⏰"></a>可度量的 ⏰</h3><p>如何知道你何时完成？这一直是我最喜欢问的一个问题。为了努力实现目标任务，不管采用什么方法，你必须能够度量它。</p><p>但是一定要采取稳扎稳打、步步为营的过程。你不能期望一周之内减掉五十英镑或者利用一个周末就学会一门全新的编程语言和它的全部函数库。度量你的目标任务，但是要采取增量进步的方法。👣</p><p>你不必看清你去往何处。不必看清你的目的地和沿途的一切。你只需要看清面前的一两米即可。 </p><h3 id="可实现的👍"><a href="#可实现的👍" class="headerlink" title="可实现的👍"></a>可实现的👍</h3><p>我想要攀登K2峰，想在中东建立永久和平。这一切不会发生。😂</p><p>至少，对我来说是这样。这些都是很好的目标，但是不现实。对我来说在当前的现实情况下无法实现。🤪</p><p>因此，先确定目标是否合理。你也许可以在下周用新语言编写一段 “Hello,World!” 或者一个简单应用，但是你可能无法编写一个完整的Web应用框架和一个带有神经网络优化算法的用户界面构造器。</p><p>从你现在所处的情况着眼，让每一个目标都可实现。🚀</p><h3 id="相关的🔗"><a href="#相关的🔗" class="headerlink" title="相关的🔗"></a>相关的🔗</h3><p>这个目标真的与你有关吗——对你重要吗？🏆你对此有热情吗？是在你控制之下的事情吗？<br>如果不是，这个目标就是不相关的。<br>目标需要相关，需要在你掌控之中🎉。</p><h3 id="时间可控的🕰"><a href="#时间可控的🕰" class="headerlink" title="时间可控的🕰"></a>时间可控的🕰</h3><p>这意味着你需要设定一个最后期限⏱。没有期限，目标会逐步衰退，永远被每天更紧急的事情所排挤。这样它永远都不会实现🥊。</p><p><strong>再强调一遍，稳扎稳打。采取循序渐进、比较细小的里程碑。当实现它们后，你会更有动力去实现下一个里程碑。</strong></p><h2 id="建立SMART任务实现你的目标。⌛️"><a href="#建立SMART任务实现你的目标。⌛️" class="headerlink" title="建立SMART任务实现你的目标。⌛️"></a>建立SMART任务实现你的目标。⌛️</h2><p>这种方法帮助你从自己的角度😀（“我”）、从更积极的角度（“我要”）😘来明确目标，要么用一般现在时，要么给出明确的时间表述（“我会💪在xx时间之前完成zyzzy”）。</p><h2 id="更大背景下的目标🚀"><a href="#更大背景下的目标🚀" class="headerlink" title="更大背景下的目标🚀"></a>更大背景下的目标🚀</h2><p>设定目标是第一步。</p><p>下一步行动是创建小任务以帮助你每天或每隔一段时间都能达到某种程度。你创建的小任务越多，你就越容易看清自己与目标的距离。</p><blockquote><p>本文大部分内容由小猿大圣摘录自 《程序员的思维修炼:开发认知潜能的九堂课 (图灵程序设计丛书)》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言-🔗&quot;&gt;&lt;a href=&quot;#前言-🔗&quot; class=&quot;headerlink&quot; title=&quot;前言 🔗&quot;&gt;&lt;/a&gt;前言 🔗&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;目标是很美好的事情，你可能会有许多目标：减肥🏃‍♂️、找到一个更好的工作👔、搬进一个更
      
    
    </summary>
    
      <category term="读书" scheme="https://hufangyun.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>新手到专家的五个阶段</title>
    <link href="https://hufangyun.com/2018/novice-to-expert-five-stage/"/>
    <id>https://hufangyun.com/2018/novice-to-expert-five-stage/</id>
    <published>2018-05-06T10:48:06.000Z</published>
    <updated>2018-05-06T10:48:06.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《程序员的思维修炼:开发认知潜能的九堂课 (图灵程序设计丛书)》读书笔记 </p></blockquote><h2 id="德雷福斯模型的5个阶段"><a href="#德雷福斯模型的5个阶段" class="headerlink" title="德雷福斯模型的5个阶段"></a>德雷福斯模型的5个阶段</h2><p><img src="/media/15256037912881.png" alt=""></p><h2 id="有效的使用德雷福斯模型"><a href="#有效的使用德雷福斯模型" class="headerlink" title="有效的使用德雷福斯模型"></a>有效的使用德雷福斯模型</h2><ul><li>需要一个明确定义的任务。 ⏱</li><li>任务需要有适当难度——有挑战性但可行。⏰</li><li>任务环境可以提供大量反馈，以便于你采取行动。🛠</li><li>提供重复犯错和纠正错误的机会。稳步做这种实践十年，你就会达到目标。💯</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;《程序员的思维修炼:开发认知潜能的九堂课 (图灵程序设计丛书)》读书笔记 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;德雷福斯模型的5个阶段&quot;&gt;&lt;a href=&quot;#德雷福斯模型的5个阶段&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="技术成长" scheme="https://hufangyun.com/categories/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>关于转载</title>
    <link href="https://hufangyun.com/2018/copyright-reprinted/"/>
    <id>https://hufangyun.com/2018/copyright-reprinted/</id>
    <published>2018-04-26T08:52:30.000Z</published>
    <updated>2018-04-27T08:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近，发现自己写的博文，被别人转载了。有商业性质的网站、有个人博主，也有各种爬虫自动采集收录。</p><p>比如这篇 <a href="https://hufangyun.com/2017/short-url/">短网址(short URL)系统的原理及其实现</a>, 我发现这篇文章在谷歌和百度搜索的时候，前5、6页搜索结果都找不到我自己的原文地址😭，只有必应第一条搜索结果是我自己的博客 😂</p><h2 id="我不希望文章被复制粘贴转载-❌"><a href="#我不希望文章被复制粘贴转载-❌" class="headerlink" title="我不希望文章被复制粘贴转载 ❌"></a>我不希望文章被复制粘贴转载 ❌</h2><ul><li><strong>我的博客是经常更新的。</strong> 🚀 我的博文是按照更新时间排序的，在编程技术领域以及社会这个大家庭中，我还很年轻，写的东西难免会有错误，或者认知上的不成熟，一旦我发现有错误或者内容补充，我会不定期的更新文章内容。但是复制粘贴转载的文章，并不会随着我更新而更新，错误的内容会一直保留，给之后的阅读者留下隐患。</li><li><strong>我不能更好的收到反馈。</strong> 我发现很多转载的文章下面，有对我文章内容的疑问和勘误，转载文章的人，并不会去解释这些疑问，而我作为文章的原创作者，也收不到别人指正的错误。对文章的阅读者和作者的我，都没有很好的反馈。</li><li><strong>阅读效果不佳。</strong> 最让我受不了的是，我在写作的时候使用了 <code>Markdown</code> 的语法画的流程图很多网站不支持显示，显示的全是代码。还有我用的表情 🐻，他们也显示不出来。。。。</li></ul><h2 id="我希望的转载方式-✅"><a href="#我希望的转载方式-✅" class="headerlink" title="我希望的转载方式 ✅"></a>我希望的转载方式 ✅</h2><p><strong>分享链接转载，指向我的博文。</strong> 我觉的这是最好的转载方式，互赢。</p><p><strong>如果，</strong> 非要复制粘贴的转载，请联系我 <strong>获得授权</strong>，未经许可禁止转载。</p><p>我会在文章的开头注明授权给了谁。我文章更新的时候，也通知转载文章的地方更新。</p><p>邮箱地址：<code>hufy78#gmail.com</code> <code>hufy3651#foxmail.com</code> <code>#</code> 换成 <code>@</code></p><h2 id="关于原创自己总结的方法"><a href="#关于原创自己总结的方法" class="headerlink" title="关于原创自己总结的方法"></a>关于原创自己总结的方法</h2><p>1、有自己的文章风格。这个好像很难。。。</p><p>2、有代码实例，指向自己的网站、Github</p><p>3、图片截图包含自己的博客域名目录等</p><p>4、截图带上自己的水印</p><p>5、每篇文章后面带上转载声明</p><p>6、文章内容示例含有自己的标识</p><h2 id="使用别人的原创"><a href="#使用别人的原创" class="headerlink" title="使用别人的原创"></a>使用别人的原创</h2><p>换位思考，以后我使用别人的图片和摘选的内容时，我会带上来源地址和作者署名，尊重原创。💪</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近，发现自己写的博文，被别人转载了。有商业性质的网站、有个人博主，也有各种爬虫自动采集收录。&lt;/p&gt;
&lt;p&gt;比如这篇 &lt;a href=&quot;https://hufangyun.com/2017/short-url/&quot;&gt;短网址(short URL)系统的原理及其实现&lt;/a&gt;, 
      
    
    </summary>
    
      <category term="随笔" scheme="https://hufangyun.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>效率神器 Alfred workflow 插件推荐</title>
    <link href="https://hufangyun.com/2018/alfred-workflow-recommend/"/>
    <id>https://hufangyun.com/2018/alfred-workflow-recommend/</id>
    <published>2018-04-19T16:38:07.000Z</published>
    <updated>2018-11-18T23:17:07.000Z</updated>
    
    <content type="html"><![CDATA[<img alt="alfred" src="https://static.hufangyun.com/hexo/img/alfred.png?imageView2/2/w/750"><span class="img-alt">alfred</span><blockquote><p>以下是我常用的 Alfred workflow</p></blockquote><p>⚠️ 不同插件，可能有不同作者开发的版本，我推荐的不一定是最好的，只是我一直在用的。比如像有道翻译，可以找到很多版本，选择自己喜欢的即可。</p><blockquote><p>新发现的插件，会添加在最上面的 🎉</p></blockquote><img alt="自用 Alfred Workfolw" src="https://static.hufangyun.com/hexo/img/my-alfred-workflow.png?imageView2/2/w/300"><span class="img-alt">自用 Alfred Workfolw</span><h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><h3 id="快递查询"><a href="#快递查询" class="headerlink" title="快递查询"></a>快递查询</h3><blockquote><p>在 <code>Alfred</code> 中查询快递，使用 <code>kd</code> 关键字，可以记录已经查过的快递和查询新快递，不需要输入快递公司名称。</p></blockquote><img alt="快递查询" src="https://static.hufangyun.com/hexo/img/alfred-express.jpg?imageView2/2/w/500"><span class="img-alt">快递查询</span><p><a href="https://github.com/roylez/alfred_kuaidi" target="_blank" rel="noopener">下载地址</a></p><h3 id="锁定屏幕"><a href="#锁定屏幕" class="headerlink" title="锁定屏幕"></a>锁定屏幕</h3><p>最近同事介绍的，是 <code>alfred</code> 自带的功能，不需要付费即可使用。</p><img src="https://static.hufangyun.com/hexo/img/alfred-lock.jpg?imageView2/2/w/500"><h3 id="http-status-code"><a href="#http-status-code" class="headerlink" title="http status code"></a>http status code</h3><blockquote><p>显示 http 状态码含义</p></blockquote><p>第一款 <a href="https://github.com/JoelQ/alfred-http" target="_blank" rel="noopener">下载地址</a></p><p>第二款 <a href="https://github.com/Dreamseer/alfred-http" target="_blank" rel="noopener">下载地址</a></p><img src="https://static.hufangyun.com/hexo/img/alfred-http.jpg?imageView2/2/w/500"><h3 id="codeVar"><a href="#codeVar" class="headerlink" title="codeVar"></a>codeVar</h3><blockquote><p>生成变量名<br>作为一名开发者，我超级 😍 这款 workflow</p></blockquote><p>支持大小驼峰、常量、下划线</p><p><a href="https://github.com/xudaolong/CodeVar" target="_blank" rel="noopener">下载地址</a></p><img src="https://static.hufangyun.com/hexo/img/alfred-var.jpg?imageView2/2/w/500"><h3 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h3><blockquote><p>颜色转换工具</p></blockquote><p>⚠️ 需要安装 <code>node.js</code> 环境</p><p><a href="https://github.com/TylerEich/Alfred-Extras/releases" target="_blank" rel="noopener">下载地址</a></p><img src="https://static.hufangyun.com/hexo/img/alfred-color.jpg?imageView2/2/w/500"><h3 id="Currency-Convert"><a href="#Currency-Convert" class="headerlink" title="Currency Convert"></a>Currency Convert</h3><blockquote><p>汇率转换</p></blockquote><p><a href="https://github.com/jin5354/alfred3-workflow-CurrencyConvert" target="_blank" rel="noopener">下载地址</a></p><img src="https://static.hufangyun.com/hexo/img/alfred-currency.jpg?imageView2/2/w/500"><h3 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h3><blockquote><p>和 macOS 上的 Dash 软件配合使用，文档搜索</p></blockquote><p>就不上截图了。</p><p><a href="https://github.com/Kapeli/Dash-Alfred-Workflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="豆瓣"><a href="#豆瓣" class="headerlink" title="豆瓣"></a>豆瓣</h3><blockquote><p>搜索豆瓣的书籍、电影、音乐，查看评分，打开相关的页面</p></blockquote><p>第一款 <a href="https://lucifr.com/2013/03/14/douban-workflow-for-alfred-v2/" target="_blank" rel="noopener">下载地址</a></p><p>作者个人的 apiKey 失效了，在 workflow 中，去掉 apiKey 即可使用了。</p><img src="https://static.hufangyun.com/hexo/img/alfred-douban-book.jpg?imageView2/2/w/500"><img src="https://static.hufangyun.com/hexo/img/alfred-douban-moive.jpg?imageView2/2/w/500"><p>第二款 <a href="https://github.com/xinhangliu/alfred-workflow/tree/master/douban-search" target="_blank" rel="noopener">下载地址</a></p><p>😄 还支持搜索用户~~</p><img src="https://static.hufangyun.com/hexo/img/alfred-douban-search.png?imageView2/2/w/500"><p>第三款 <a href="https://github.com/swim2sun/Douban-Movie-Workflow" target="_blank" rel="noopener">下载地址</a></p><p>❗这一款，仅支持豆瓣电影</p><img src="https://static.hufangyun.com/hexo/img/alfred-douban-movie.png?imageView2/2/w/500"><h3 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h3><blockquote><p>搜索表情</p></blockquote><p>第一款</p><ul><li>常用的表情会放在最上面，但是使用的关键词匹配，经常搜不出自己想要的表情</li><li>好处是开箱即用，而下面一款，需要安装 <code>node.js</code> 环境。</li></ul><p><a href="https://github.com/carlosgaldino/alfred-emoji-workflow" target="_blank" rel="noopener">下载地址</a></p><img src="https://static.hufangyun.com/hexo/img/alfred-emoji.jpg?imageView2/2/w/500"><p>第二款</p><ul><li>搜索结果会把相关的表情都展示出来，不只是关键词匹配。</li><li><code>node.js</code> 开发的，需要安装一些必要的环境。</li></ul><p>[下载地址](<a href="https://github.com/sindresorhus/alfred-emoj）" target="_blank" rel="noopener">https://github.com/sindresorhus/alfred-emoj）</a></p><img src="https://static.hufangyun.com/hexo/img/alfred-emoji-npm.jpg?imageView2/2/w/500"><h3 id="Encode-Decode"><a href="#Encode-Decode" class="headerlink" title="Encode/Decode"></a>Encode/Decode</h3><blockquote><p>编码解码工具</p></blockquote><p><a href="https://github.com/willfarrell/alfred-encode-decode-workflow" target="_blank" rel="noopener">下载地址</a></p><img src="https://static.hufangyun.com/hexo/img/alfred-encode.jpg?imageView2/2/w/500"><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><blockquote><p>快速查找项目、用户</p></blockquote><p><a href="https://github.com/gharlan/alfred-github-workflow" target="_blank" rel="noopener">下载地址</a></p><img src="https://static.hufangyun.com/hexo/img/alfred-github.jpg?imageView2/2/w/500"><h3 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab"></a>Gitlab</h3><blockquote><p>快速搜索并打开项目，支持自定义域名的 gitlab</p></blockquote><p><a href="https://github.com/lukewaite/alfred-gitlab" target="_blank" rel="noopener">下载地址</a></p><p>默认配置的是 <a href="https://gitlab.com/explore" target="_blank" rel="noopener"><code>gitlab</code></a>, 也可以设置公司的 <code>gitlab</code></p><p>输入 <code>glseturl</code> 空格后，输入地址。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//&lt;host&gt;/api/v4/projects</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// host 换成自己公司的</span></span><br></pre></td></tr></table></figure><img src="https://static.hufangyun.com/hexo/img/alfred-gitlab.jpg?imageView2/2/w/500"><h3 id="nameBeta"><a href="#nameBeta" class="headerlink" title="nameBeta"></a>nameBeta</h3><blockquote><p>基于 namebata.com 的查询域名是否注册的工具<br>我自己写的，developing</p></blockquote><p><a href="https://github.com/Youthink/alfred-namebeta-workflow" target="_blank" rel="noopener">下载地址</a></p><img src="https://static.hufangyun.com/hexo/img/alfred-namebeta.jpg?imageView2/2/w/500"><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><blockquote><p>搜索 npm 包</p></blockquote><p><a href="https://github.com/onvno/alfred-package-workflow" target="_blank" rel="noopener">下载地址</a></p><img src="https://static.hufangyun.com/hexo/img/alfred-node.jpg?imageView2/2/w/500"><h3 id="Package-Managers"><a href="#Package-Managers" class="headerlink" title="Package Managers"></a>Package Managers</h3><blockquote><p>上面的插件只能搜索 npm 包，这个就强大了 <code>yarn</code> <code>npm</code> <code>yo</code> <code>brew</code> <code>apt-get</code> <code>composer</code> <code>docker</code> <code>gems</code> <code>gradle</code> <code>hex</code> <code>maven</code> <code>pypi</code> 等等，很多语言以及工具的包都可以搜索。</p></blockquote><p><a href="https://github.com/willfarrell/alfred-pkgman-workflow" target="_blank" rel="noopener">下载地址</a></p><h3 id="Search-Evernote-Chinese-Edition"><a href="#Search-Evernote-Chinese-Edition" class="headerlink" title="Search Evernote (Chinese Edition)"></a>Search Evernote (Chinese Edition)</h3><blockquote><p>搜索印象笔记</p></blockquote><p><a href="https://github.com/patricorgi/alfred-evernote" target="_blank" rel="noopener">下载地址</a></p><h3 id="timestamp-helper"><a href="#timestamp-helper" class="headerlink" title="timestamp-helper"></a>timestamp-helper</h3><blockquote><p>时间戳转换</p></blockquote><p><a href="http://www.packal.org/workflow/timestamp" target="_blank" rel="noopener">下载地址</a></p><img src="https://static.hufangyun.com/hexo/img/alfred-timestamp.jpg?imageView2/2/w/500"><h3 id="有道翻译"><a href="#有道翻译" class="headerlink" title="有道翻译"></a>有道翻译</h3><blockquote><p>单词、句子翻译，支持发音</p></blockquote><p><a href="https://github.com/liszd/whyliam.workflows.youdao" target="_blank" rel="noopener">下载地址</a></p><img src="https://static.hufangyun.com/hexo/img/alfred-youdao.jpg?imageView2/2/w/500"><h3 id="Open-with-MacVim"><a href="#Open-with-MacVim" class="headerlink" title="Open with MacVim"></a>Open with MacVim</h3><blockquote><p>使用 MacVim 打开文件</p></blockquote><p><a href="https://github.com/franzheidl/alfred-workflows/tree/master/open-with-macvim" target="_blank" rel="noopener">下载地址</a></p><img src="https://static.hufangyun.com/hexo/img/alfred-macvim.jpg?imageView2/2/w/500"><h3 id="AlfredHiddenFilesToggle"><a href="#AlfredHiddenFilesToggle" class="headerlink" title="AlfredHiddenFilesToggle"></a>AlfredHiddenFilesToggle</h3><blockquote><p>macOS 显示隐藏文件</p></blockquote><p><a href="https://github.com/logic1988/AlfredHiddenFilesToggle" target="_blank" rel="noopener">下载地址</a></p><h2 id="插件搜索"><a href="#插件搜索" class="headerlink" title="插件搜索"></a>插件搜索</h2><blockquote><p>可以在这三个地方寻找插件</p></blockquote><ul><li><p><a href="http://www.packal.org/" target="_blank" rel="noopener">packal</a></p></li><li><p><a href="http://www.alfredworkflow.com/" target="_blank" rel="noopener">alfredworkflow</a></p></li><li><p><a href="https://github.com" target="_blank" rel="noopener">Github</a></p></li></ul><p><strong>本文会时常更新，❤️ 的话，可以收藏一下。</strong></p><blockquote><p>欢迎来<a href="https://hufangyun.com">我的博客</a>评论交流，爬虫那么多，评论在其他地方我可能看不到 😂</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;img alt=&quot;alfred&quot; src=&quot;https://static.hufangyun.com/hexo/img/alfred.png?imageView2/2/w/750&quot;&gt;&lt;span class=&quot;img-alt&quot;&gt;alfred&lt;/span&gt;
&lt;blockquote&gt;
      
    
    </summary>
    
      <category term="最热" scheme="https://hufangyun.com/categories/%E6%9C%80%E7%83%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>loading 等待不再无聊</title>
    <link href="https://hufangyun.com/2018/loading/"/>
    <id>https://hufangyun.com/2018/loading/</id>
    <published>2018-03-27T06:20:01.000Z</published>
    <updated>2018-03-27T06:20:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/media/Spinner-1s-200px.gif" alt="Spinner-1s-200px"><span class="img-alt">Spinner-1s-200px</span></p><blockquote><p>很多应用在加载的时候，因为数据还没有返回，会给用户呈现一个加载的动效作为反馈，提示用户数据正在加载。但是如果页面加载的时间太长，可能就会导致用户流失。</p><p>其实等待加载的这个小细节里，也有很多的创意，让等待不在无聊。</p></blockquote><p>为了让用户能稍等片刻，<code>loading</code> 的设计就可以充满趣味性，这里介绍一些比较有趣的 <code>loading</code>，让等待的过程变成了一种享受。</p><h2 id="使用充满趣味性的加载动效"><a href="#使用充满趣味性的加载动效" class="headerlink" title="使用充满趣味性的加载动效"></a>使用充满趣味性的加载动效</h2><p><img src="http://image.woshipm.com/wp-files/2017/02/a4WTx4yop7z4oCVUMIUl.gif" alt=""></p><p><img src="/media/pdECLTLpVFMr4Jc8xCWb.gif" alt="pdECLTLpVFMr4Jc8xCWb"><span class="img-alt">pdECLTLpVFMr4Jc8xCWb</span></p><p><img src="/media/161ZG138-44.gif" alt="161ZG138-44"><span class="img-alt">161ZG138-44</span></p><p><img src="/media/161ZJ0S-14.gif" alt="161ZJ0S-14"><span class="img-alt">161ZJ0S-14</span></p><p><img src="/media/815442-b0b53e2a86279228.gif" alt="815442-b0b53e2a86279228"><span class="img-alt">815442-b0b53e2a86279228</span></p><p><img src="/media/815442-6f23db9af75006ff.gif" alt="815442-6f23db9af75006ff"><span class="img-alt">815442-6f23db9af75006ff</span></p><p><img src="/media/giphy.gif" alt="giphy"><span class="img-alt">giphy</span></p><h3 id="品牌的-loading"><a href="#品牌的-loading" class="headerlink" title="品牌的 loading"></a>品牌的 loading</h3><blockquote><p>嵌入自家 logo，强化产品品牌</p></blockquote><h4 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h4><p><img src="/media/04-google-loading-motion-dots-logo.gif" alt="04-google-loading-motion-dots-logo"><span class="img-alt">04-google-loading-motion-dots-logo</span></p><h4 id="slack"><a href="#slack" class="headerlink" title="slack"></a>slack</h4><p><img src="/media/slack_load.gif" alt="slack_load"><span class="img-alt">slack_load</span></p><h4 id="digg"><a href="#digg" class="headerlink" title="digg"></a>digg</h4><p><img src="/media/815442-668ae4eaf45aab9b.gif" alt="815442-668ae4eaf45aab9b"><span class="img-alt">815442-668ae4eaf45aab9b</span></p><blockquote><p>上面的 <code>loading</code> 用户初次见到时候可能会感到比较新颖，但是多次遇到 <code>loading</code> 后，趣味性就递减了。</p></blockquote><p>我常用的一款 app 的 <code>loading</code> 就很有意思，每次的文案不一样，而且充满趣味性。</p><p>这样的 app 即使出现 <code>loading</code>，用户不会有等待感，反而想看清楚显示的是什么，对每次的文案充满期待。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let noticeString = [</span><br><span class="line">    &quot;正在拼命加载&quot;,</span><br><span class="line">    &quot;前方发现楼主&quot;,</span><br><span class="line">    &quot;年轻人,不要着急&quot;,</span><br><span class="line">    &quot;让我飞一会儿&quot;,</span><br><span class="line">    &quot;大爷,您又来了?&quot;,</span><br><span class="line">    &quot;楼主正在抓皮卡丘，等他一会儿吧&quot;,</span><br><span class="line">    &quot;爱我，就等我一万年&quot;,</span><br><span class="line">    &quot;未满18禁止入内&quot;,</span><br><span class="line">    &quot;正在前往 花村&quot;,</span><br><span class="line">    &quot;正在前往 阿努比斯神殿&quot;,</span><br><span class="line">    &quot;正在前往 沃斯卡娅工业区&quot;,</span><br><span class="line">    &quot;正在前往 观测站：直布罗陀&quot;,</span><br><span class="line">    &quot;正在前往 好莱坞&quot;,</span><br><span class="line">    &quot;正在前往 66号公路&quot;,</span><br><span class="line">    &quot;正在前往 国王大道&quot;,</span><br><span class="line">    &quot;正在前往 伊利奥斯&quot;,</span><br><span class="line">    &quot;正在前往 漓江塔&quot;,</span><br><span class="line">    &quot;正在前往 尼泊尔&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><blockquote><p>最后，附上几个 <code>loading</code> 生成工具。</p></blockquote><h3 id="loading-io"><a href="#loading-io" class="headerlink" title="loading.io"></a>loading.io</h3><p><a href="https://loading.io/" target="_blank" rel="noopener">https://loading.io/</a></p><p>登陆后，免费下载，支持 <code>loading</code> 动效的各种格式导出。</p><p><img src="/media/15221417078807.jpg" alt=""></p><h3 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h3><p><a href="https://connoratherton.com/loaders" target="_blank" rel="noopener">https://connoratherton.com/loaders</a></p><p>纯 <code>css</code> 实现的 <code>loading</code></p><p><img src="/media/15221417417648.jpg" alt=""></p><h3 id="spin-js"><a href="#spin-js" class="headerlink" title="spin.js"></a>spin.js</h3><p><a href="http://spin.js.org/" target="_blank" rel="noopener">http://spin.js.org/</a></p><p>在线编辑各种参数</p><p><img src="/media/15221418378683.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/media/Spinner-1s-200px.gif&quot; alt=&quot;Spinner-1s-200px&quot;&gt;&lt;span class=&quot;img-alt&quot;&gt;Spinner-1s-200px&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很多应用在加载的时
      
    
    </summary>
    
      <category term="编程" scheme="https://hufangyun.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
